<!DOCTYPE html><html><head>
    <meta charset="utf-8">
    <title>Polymer</title>

    <link rel="stylesheet" href="http://pasteup.guim.co.uk/0.0.5/css/fonts.pasteup.min.css">
    <link rel="stylesheet" href="../normalize.css">
    <link rel="stylesheet" href="../base-styles.css">

    <script>/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function() {

  // Establish scope.
  window.WebComponents = window.WebComponents || {flags:{}};

  // loading script
  var file = 'webcomponents-lite.js';
  var script = document.querySelector('script[src*="' + file + '"]');

  // Flags. Convert url arguments to flags
  var flags = {};
  if (!flags.noOpts) {
    // from url
    location.search.slice(1).split('&').forEach(function(option) {
      var parts = option.split('=');
      var match;
      if (parts[0] && (match = parts[0].match(/wc-(.+)/))) {
        flags[match[1]] = parts[1] || true;
      }
    });
    // from script
    if (script) {
      for (var i=0, a; (a=script.attributes[i]); i++) {
        if (a.name !== 'src') {
          flags[a.name] = a.value || true;
        }
      }
    }
    // log flags
    if (flags.log && flags.log.split) {
      var parts = flags.log.split(',');
      flags.log = {};
      parts.forEach(function(f) {
        flags.log[f] = true;
      });
    } else {
      flags.log = {};
    }
  }

  // construct full dependency list
  var modules = [
    'URL/URL.js',
    'WeakMap/WeakMap.js',
    'Template/Template.js',
    'HTMLImports/HTMLImports.js',
    'WebComponents/Promise.js',
    'WebComponents/pre-polyfill.js',
    '../../custom-elements/custom-elements.min.js',
    '../../shadydom/shadydom.min.js',
    '../../shadycss/shadycss.min.js',
    'WebComponents/post-polyfill.js',
    // these scripts are loaded here due to polyfill timing issues
    'WebComponents/lang.js',
    'WebComponents/dom.js',
    'WebComponents/unresolved.js'
  ];

  var src = script.getAttribute('src');
  var path = src.slice(0, src.lastIndexOf(file));

  modules.forEach(function(f) {
    document.write('<script src="' + path + 'src/' + f + '"><\/script>');
  });

  // exports
  WebComponents.flags = flags;


})();
</script>

    <!-- Load the Polymer.Element base class -->
    </head>
  <body><div hidden="" by-vulcanize=""><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  window.Polymer = window.Polymer || {};
  window.Polymer.version = '2.0-preview';

</script>
<script>

(function() {

  var modules = {};
  var lcModules = {};
  var findModule = function(id) {
    return modules[id] || lcModules[id.toLowerCase()];
  };

  /**
   * The `dom-module` element registers the dom it contains to the name given
   * by the module's id attribute. It provides a unified database of dom
   * accessible via any dom-module element. Use the `import(id, selector)`
   * method to locate dom within this database. For example,
   *
   * <dom-module id="foo">
   *   <img src="stuff.png">
   * </dom-module>
   *
   * Then in code in some other location that cannot access the dom-module above
   *
   * var img = document.createElement('dom-module').import('foo', 'img');
   *
   */
  class DomModule extends HTMLElement {

    static get observedAttributes() { return ['id'] }

    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this.register();
      }
    }

    _styleOutsideTemplateCheck() {
      if (this.querySelector('style')) {
        console.warn('dom-module %s has style outside template', this.id);
      }
    }

    /**
     * Registers the dom-module at a given id. This method should only be called
     * when a dom-module is imperatively created. For
     * example, `document.createElement('dom-module').register('foo')`.
     * @method register
     * @param {String} id The id at which to register the dom-module.
     */
    register(id) {
      id = id || this.id;
      if (id) {
        this.id = id;
        // store id separate from lowercased id so that
        // in all cases mixedCase id will stored distinctly
        // and lowercase version is a fallback
        modules[id] = this;
        lcModules[id.toLowerCase()] = this;
        this._styleOutsideTemplateCheck();
      }
    }

    /**
     * Retrieves the dom specified by `selector` in the module specified by
     * `id`. For example, this.import('foo', 'img');
     * @method register
     * @param {String} id
     * @param {String} selector
     * @return {Object} Returns the dom which matches `selector` in the module
     * at the specified `id`.
     */
    import(id, selector) {
      if (id) {
        var m = findModule(id);
        if (m && selector) {
          return m.querySelector(selector);
        }
        return m;
      }
    }

  }

  customElements.define('dom-module', DomModule);

  // export
  Polymer.DomModule = new DomModule();

  Polymer.DomModule.modules = modules;

})();

</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  Polymer.CaseMap = {

    _caseMap: {},
    _rx: {
      dashToCamel: /-[a-z]/g,
      camelToDash: /([A-Z])/g
    },

    dashToCamelCase: function(dash) {
      return this._caseMap[dash] || (
        this._caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(this._rx.dashToCamel,
          function(m) {
            return m[1].toUpperCase();
          }
        )
      );
    },

    camelToDashCase: function(camel) {
      return this._caseMap[camel] || (
        this._caseMap[camel] = camel.replace(this._rx.camelToDash, '-$1').toLowerCase()
      );
    }

  };

</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

(function() {

  'use strict';

  var p = Element.prototype;
   var matchesSelector = p.matches || p.matchesSelector ||
     p.mozMatchesSelector || p.msMatchesSelector ||
     p.oMatchesSelector || p.webkitMatchesSelector;

  Polymer.Utils = {

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @method mixin
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin(target, source) {
      for (var i in source) {
        target[i] = source[i];
      }
      return target;
    },

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @method extend
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend(prototype, api) {
      if (prototype && api) {
        var n$ = Object.getOwnPropertyNames(api);
        for (var i=0, n; (i<n$.length) && (n=n$[i]); i++) {
          this.copyOwnProperty(n, api, prototype);
        }
      }
      return prototype || api;
    },

    copyOwnProperty(name, source, target) {
      var pd = Object.getOwnPropertyDescriptor(source, name);
      if (pd) {
        Object.defineProperty(target, name, pd);
      }
    },

    // only needed for v0 native ShadowDOM support
    getRootNode(node) {
      if (node.getRootNode) {
        return node.getRootNode();
      }
      if (!node) {
        return null;
      }
      while(node && node.parentNode) {
        node = node.parentNode;
      }
      return node;
    },

    matchesSelector(node, selector) {
      return matchesSelector.call(node, selector);
    },

    cachingMixin(mixin) {
      return function(base) {
        if (!mixin.__mixinApplications) {
          mixin.__mixinApplications = new WeakMap();
        }
        let application = mixin.__mixinApplications.get(base);
        if (!application) {
          application = mixin(base);
          mixin.__mixinApplications.set(base, application);
        }
        return application;
      }
    },

    dedupingMixin(mixin) {
      mixin = this.cachingMixin(mixin);
      return function(base) {
        let baseMap = base.__mixinMap;
        if (baseMap && baseMap.get(mixin)) {
          return base;
        } else {
          let extended = mixin(base);
          extended.__mixinMap = new Map(baseMap);
          extended.__mixinMap.set(mixin, true);
          return extended;
        }
      }
    },

    /**
     * Convenience method for importing an HTML document imperatively.
     *
     * This method creates a new `<link rel="import">` element with
     * the provided URL and appends it to the document to start loading.
     * In the `onload` callback, the `import` property of the `link`
     * element will contain the imported document contents.
     *
     * @method importHref
     * @param {string} href URL to document to load.
     * @param {Function} onload Callback to notify when an import successfully
     *   loaded.
     * @param {Function} onerror Callback to notify when an import
     *   unsuccessfully loaded.
     * @param {boolean} optAsync True if the import should be loaded `async`.
     *   Defaults to `false`.
     * @return {HTMLLinkElement} The link element for the URL to be loaded.
     */
    importHref(href, onload, onerror, optAsync) {
      var l = document.createElement('link');
      l.rel = 'import';
      l.href = href;

      optAsync = Boolean(optAsync);
      if (optAsync) {
        l.setAttribute('async', '');
      }

      var self = this;
      if (onload) {
        l.onload = function(e) {
          // NOTE: Push load handler until after `HTMLImports.whenReady`,
          // if available, to better coordinate with use of customElements
          // polyfill's document upgrade ordering guarantees (ensures,
          // for example, a dom-module for an element in an async import
          // customizes before any elements matching a define call).
          if (window.HTMLImports) {
            // wait until any other pending imports are ready
            HTMLImports.whenReady(function() {
              // wait until the CustomElements polyfill has upgraded elements.
              // (needed because CE's whenReady is installed afer this one)
              setTimeout(function() {
                onload.call(self, e);
              });
            });
          } else {
            onload.call(self, e);
          }
        }
      }
      if (onerror) {
        l.onerror = function(e) {
          onerror.call(self, e);
        }
      }
      document.head.appendChild(l);
      return l;
    }

  };

})();

</script><script>
(function() {

  'use strict';

  function createNodeEventHandler(context, eventName, methodName) {
    context = context._rootDataHost || context;
    var handler = function(e) {
      if (context[methodName]) {
        context[methodName](e, e.detail);
      } else {
        console.warn('listener method `' + methodName + '` not defined');
      }
    };
    return handler;
  }

  Polymer.EventListeners = Polymer.Utils.dedupingMixin(function(superClass) {

    return class EventListeners extends superClass {

      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        var handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }

      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }

      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }

    }

  });

})();
</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  (function() {

    // path fixup for urls in cssText that's expected to
    // come from a given ownerDocument
    function resolveCss(cssText, ownerDocument) {
      return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
        return pre + '\'' +
          resolve(url.replace(/["']/g, ''), ownerDocument) +
          '\'' + post;
      });
    }

    // url fixup for urls in an element's attributes made relative to
    // ownerDoc's base url
    function resolveAttrs(element, ownerDocument) {
      for (var name in URL_ATTRS) {
        var a$ = URL_ATTRS[name];
        for (var i=0, l=a$.length, a, at, v; (i<l) && (a=a$[i]); i++) {
          if (name === '*' || element.localName === name) {
            at = element.attributes[a];
            v = at && at.value;
            if (v && (v.search(BINDING_RX) < 0)) {
              at.value = (a === 'style') ?
                resolveCss(v, ownerDocument) :
                resolve(v, ownerDocument);
            }
          }
        }
      }
    }

    function resolve(url, ownerDocument) {
      // do not resolve '#' links, they are used for routing
      if (url && ABS_URL.test(url)) {
        return url;
      }
      var resolver = getUrlResolver(ownerDocument);
      resolver.href = url;
      return resolver.href || url;
    }

    var tempDoc;
    var tempDocBase;
    function resolveUrl(url, baseUri) {
      if (!tempDoc) {
        tempDoc = document.implementation.createHTMLDocument('temp');
        tempDocBase = tempDoc.createElement('base');
        tempDoc.head.appendChild(tempDocBase);
      }
      tempDocBase.href = baseUri;
      return resolve(url, tempDoc);
    }

    function getUrlResolver(ownerDocument) {
      return ownerDocument.__urlResolver ||
        (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
    }

    var CSS_URL_RX = /(url\()([^)]*)(\))/g;
    var URL_ATTRS = {
      '*': ['href', 'src', 'style', 'url'],
      form: ['action']
    };
    var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
    var BINDING_RX = /\{\{|\[\[/;

    // exports
    Polymer.ResolveUrl = {
      resolveCss: resolveCss,
      resolveAttrs: resolveAttrs,
      resolveUrl: resolveUrl
    };

  })();

</script>
<script>
/**
 * Scans a template to produce an annotation list that that associates
 * metadata culled from markup with tree locations
 * metadata and information to associate the metadata with nodes in an instance.
 *
 * Supported expressions include:
 *
 * Double-mustache annotations in text content. The annotation must be the only
 * content in the tag, compound expressions are not supported.
 *
 *     <[tag]>{{annotation}}<[tag]>
 *
 * Double-escaped annotations in an attribute, either {{}} or [[]].
 *
 *     <[tag] someAttribute="{{annotation}}" another="[[annotation]]"><[tag]>
 *
 * `on-` style event declarations.
 *
 *     <[tag] on-<event-name>="annotation"><[tag]>
 *
 * Note that the `annotations` feature does not implement any behaviors
 * associated with these expressions, it only captures the data.
 *
 * Generated data-structure:
 *
 *     [
 *       {
 *         id: '<id>',
 *         events: [
 *           {
 *             name: '<name>'
 *             value: '<annotation>'
 *           }, ...
 *         ],
 *         bindings: [
 *           {
 *             kind: ['text'|'attribute'],
 *             mode: ['{'|'['],
 *             name: '<name>'
 *             value: '<annotation>'
 *           }, ...
 *         ],
 *         // TODO(sjmiles): this is annotation-parent, not node-parent
 *         parent: <reference to parent annotation object>,
 *         index: <integer index in parent's childNodes collection>
 *       },
 *       ...
 *     ]
 *
 * @class Annotations feature
 */
(function() {

  'use strict';

  // null-array (shared empty array to avoid null-checks)
  const emptyArray = [];

  let bindingRegex = (function() {
    let IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
    let NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
    let SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
    let DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
    let STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
    let ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' +  STRING + '\\s*' + ')';
    let ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
    let ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                                  '(?:' + ARGUMENTS + '?' + ')' +
                                '\\)\\s*' + ')';
    let BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
    let OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
    let CLOSE_BRACKET = '(?:]]|}})';
    let NEGATE = '(?:(!)\\s*)?'; // Group 2
    let EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
    return new RegExp(EXPRESSION, "g");
  })();

  let insertionPointTag = 'slot';
  let currentTemplate;

  function parseTemplateAnnotations(template) {
    // TODO(kschaaf): File issue and/or remove when fixed
    // hold a reference to content as _content to prevent odd Chrome gc issue
    // nested templates also may receive their content as _content
    let content = (template._content = template._content || template.content);
    // since a template may be re-used, memo-ize notes.
    if (!content._notes) {
      content._notes = [];
      // TODO(sorvell): whitespace and processAnnotations need to be factored
      // into plugins
      // TODO(kschaaf): template should be threaded through rather than implied state
      currentTemplate = currentTemplate || template;
      parseNodeAnnotations(content, content._notes,
        template.hasAttribute('strip-whitespace'));
    }
    return content._notes;
  }

  // add annotations gleaned from subtree at `node` to `list`
  function parseNodeAnnotations(node, list, stripWhiteSpace) {
    return node.nodeType === Node.TEXT_NODE ?
      parseTextNodeAnnotation(node, list) :
        // TODO(sjmiles): are there other nodes we may encounter
        // that are not TEXT_NODE but also not ELEMENT?
        parseElementAnnotations(node, list, stripWhiteSpace);
  }

  // TODO(kschaaf): We could modify this to allow an escape mechanism by
  // looking for the escape sequence in each of the matches and converting
  // the part back to a literal type, and then bailing if only literals
  // were found
  function parseBindings(text) {
    let parts = [];
    let lastIndex = 0;
    let m;
    // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
    // Regex matches:
    //        Iteration 1:  Iteration 2:
    // m[1]: '{{'          '[['
    // m[2]: ''            '!'
    // m[3]: 'prop'        'compute(foo,bar)'
    while ((m = bindingRegex.exec(text)) !== null) {
      // Add literal part
      if (m.index > lastIndex) {
        parts.push({literal: text.slice(lastIndex, m.index)});
      }
      // Add binding part
      // Mode (one-way or two)
      let mode = m[1][0];
      let negate = Boolean(m[2]);
      let value = m[3].trim();
      let customEvent, notifyEvent, colon;
      if (mode == '{' && (colon = value.indexOf('::')) > 0) {
        notifyEvent = value.substring(colon + 2);
        value = value.substring(0, colon);
        customEvent = true;
      }
      parts.push({
        compoundIndex: parts.length,
        value: value,
        mode: mode,
        negate: negate,
        event: notifyEvent,
        customEvent: customEvent
      });
      lastIndex = bindingRegex.lastIndex;
    }
    // Add a final literal part
    if (lastIndex && lastIndex < text.length) {
      let literal = text.substring(lastIndex);
      if (literal) {
        parts.push({
          literal: literal
        });
      }
    }
    if (parts.length) {
      return parts;
    }
  }

  function literalFromParts(parts) {
    let s = '';
    for (let i=0; i<parts.length; i++) {
      let literal = parts[i].literal;
      s += literal || '';
    }
    return s;
  }

  // add annotations gleaned from TextNode `node` to `list`
  function parseTextNodeAnnotation(node, list) {
    let parts = parseBindings(node.textContent);
    if (parts) {
      // Initialize the textContent with any literal parts
      // NOTE: default to a space here so the textNode remains; some browsers
      // (IE) evacipate an empty textNode following cloneNode/importNode.
      node.textContent = literalFromParts(parts) || ' ';
      let note = {
        bindings: [{
          kind: 'text',
          name: 'textContent',
          parts: parts,
          isCompound: parts.length !== 1
        }]
      };
      list.push(note);
      return note;
    }
  }

  // add annotations gleaned from Element `node` to `list`
  function parseElementAnnotations(element, list, stripWhiteSpace) {
    let note = {
      bindings: [],
      events: []
    };
    if (element.localName === insertionPointTag) {
      list._hasInsertionPoint = true;
    }
    parseChildNodesAnnotations(element, note, list, stripWhiteSpace);
    // TODO(sjmiles): is this for non-ELEMENT nodes? If so, we should
    // change the contract of this method, or filter these out above.
    if (element.attributes) {
      parseNodeAttributeAnnotations(element, note, list);
      // TODO(sorvell): ad hoc callback for doing work on elements while
      // leveraging annotator's tree walk.
      // Consider adding an node callback registry and moving specific
      // processing out of this module.
      prepElement(element);
    }
    if (note.bindings.length || note.events.length || note.id) {
      list.push(note);
    }
    return note;
  }

  // add annotations gleaned from children of `root` to `list`, `root`'s
  // `note` is supplied as it is the note.parent of added annotations
  function parseChildNodesAnnotations(root, note, list, stripWhiteSpace) {
    if (root.firstChild) {
      let node = root.firstChild;
      let i = 0;
      while (node) {
        // BREAKME(kschaaf): pseudo-bc auto-wrapper for template type extensions
        if (node.localName === 'template') {
          let t = node;
          let is = t.getAttribute('is');
          // stamp `<dom-*>` elements
          if (is && is.indexOf('dom-') === 0) {
            t.removeAttribute('is');
            node = t.ownerDocument.createElement(is);
            root.replaceChild(node, t);
            node.appendChild(t);
            while(t.attributes.length) {
              node.setAttribute(t.attributes[0].name, t.attributes[0].value);
              t.removeAttribute(t.attributes[0].name);
            }
          }
        }
        if (node.localName === 'template' &&
          !node.hasAttribute('preserve-content')) {
          parseTemplate(node, i, list, note);
        }
        // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.
        let next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          // optionally strip whitespace
          if (stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            // decrement index since node is removed
            i--;
          }
        }
        // if this node didn't get evacipated, parse it.
        if (node.parentNode) {
          let childAnnotation = parseNodeAnnotations(node, list,
            stripWhiteSpace);
          if (childAnnotation) {
            childAnnotation.parent = note;
            childAnnotation.index = i;
          }
        }
        node = next;
        i++;
      }
    }
  }

  // 1. Parse annotations from the template and memoize them on
  //    content._notes (recurses into nested templates)
  // 2. Remove template.content and store it in annotation list, where it
  //    will be the responsibility of the host to set it back to the template
  //    (this is both an optimization to avoid re-stamping nested template
  //    children and avoids a bug in Chrome where nested template children
  //    upgrade)
  function parseTemplate(node, index, list, parent) {
    let content = document.createDocumentFragment();
    content._notes = parseTemplateAnnotations(node);
    content.appendChild(node.content);
    list.push({
      bindings: emptyArray,
      events: emptyArray,
      templateContent: content,
      parent: parent,
      index: index
    });
  }

  // add annotation data from attributes to the `annotation` for node `node`
  // TODO(sjmiles): the distinction between an `annotation` and
  // `annotation data` is not as clear as it could be
  function parseNodeAttributeAnnotations(node, annotation) {
    // Make copy of original attribute list, since the order may change
    // as attributes are added and removed
    let attrs = Array.prototype.slice.call(node.attributes);
    for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
      let n = a.name;
      let v = a.value;
      let b;
      // events (on-*)
      if (n.slice(0, 3) === 'on-') {
        node.removeAttribute(n);
        annotation.events.push({
          name: n.slice(3),
          value: v
        });
      }
      // bindings (other attributes)
      else if ((b = parseNodeAttributeAnnotation(node, n, v))) {
        annotation.bindings.push(b);
      }
      // static id
      else if (n === 'id') {
        annotation.id = v;
      }
    }
  }

  // construct annotation data from a generic attribute, or undefined
  function parseNodeAttributeAnnotation(node, name, value) {
    let parts = parseBindings(value);
    if (parts) {
      // Attribute or property
      let origName = name;
      let kind = 'property';
      if (name[name.length-1] == '$') {
        name = name.slice(0, -1);
        kind = 'attribute';
      }
      // Initialize attribute bindings with any literal parts
      let literal = literalFromParts(parts);
      if (literal && kind == 'attribute') {
        node.setAttribute(name, literal);
      }
      // Clear attribute before removing, since IE won't allow removing
      // `value` attribute if it previously had a value (can't
      // unconditionally set '' before removing since attributes with `$`
      // can't be set using setAttribute)
      if (node.localName === 'input' && origName === 'value') {
        node.setAttribute(origName, '');
      }
      // Remove annotation
      node.removeAttribute(origName);
      // Case hackery: attributes are lower-case, but bind targets
      // (properties) are case sensitive. Gambit is to map dash-case to
      // camel-case: `foo-bar` becomes `fooBar`.
      // Attribute bindings are excepted.
      let propertyName = Polymer.CaseMap.dashToCamelCase(name);
      if (kind === 'property') {
        name = propertyName;
      }
      return {
        kind: kind,
        name: name,
        propertyName: propertyName,
        parts: parts,
        literal: literal,
        isCompound: parts.length !== 1
      };
    }
  }

  // TODO(sorvell): this should be factored into a plugin
  function prepElement(element) {
    Polymer.ResolveUrl.resolveAttrs(element, currentTemplate.ownerDocument);
  }

  Polymer.Annotations = Polymer.Utils.dedupingMixin(function(superClass) {

    return class Annotations extends superClass {

      // preprocess-time

      // construct and return a list of annotation records
      // by scanning `template`'s content
      //
      // TODO(sorvell): This should just crawl over a template and call
      // a supplied list of callbacks.
      _parseTemplateAnnotations(template) {
        return parseTemplateAnnotations(template);
      }

      // instance-time
      // TODO(sorvell): consider trying to use QS instead of this proprietary
      // search. This would require some unique way to identify a node, a guid.
      // Is this faster? simpler? Is that worth polluting the node?
      _findTemplateAnnotatedNode(root, note) {
        // recursively ascend tree until we hit root
        let parent = note.parent && this._findTemplateAnnotatedNode(root,
          note.parent);
        // unwind the stack, returning the indexed node at each level
        if (parent) {
          // note: marginally faster than indexing via childNodes
          // (http://jsperf.com/childnodes-lookup)
          for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
            if (note.index === i++) {
              return n;
            }
          }
        } else {
          return root;
        }
      }

    }

  });

})();
</script><script>
(function() {

  'use strict';

  /**
   * Scans a template to produce an annotation object that stores expression
   * metadata along with information to associate the metadata with nodes in an
   * instance.
   *
   * Elements with `id` in the template are noted and marshaled into an
   * the `$` hash in an instance.
   *
   * Example
   *
   *     &lt;template>
   *       &lt;div id="foo">&lt;/div>
   *     &lt;/template>
   *     &lt;script>
   *      Polymer({
   *        task: function() {
   *          this.$.foo.style.color = 'red';
   *        }
   *      });
   *     &lt;/script>
   *
   * Other expressions that are noted include:
   *
   * Double-mustache annotations in text content. The annotation must be the only
   * content in the tag, compound expressions are not (currently) supported.
   *
   *     <[tag]>{{path.to.host.property}}<[tag]>
   *
   * Double-mustache annotations in an attribute.
   *
   *     <[tag] someAttribute="{{path.to.host.property}}"><[tag]>
   *
   * Only immediate host properties can automatically trigger side-effects.
   * Setting `host.path` in the example above triggers the binding, setting
   * `host.path.to.host.property` does not.
   *
   * `on-` style event declarations.
   *
   *     <[tag] on-<event-name>="{{hostMethodName}}"><[tag]>
   *
   * Note: **the `annotations` feature does not actually implement the behaviors
   * associated with these expressions, it only captures the data**.
   *
   * Other optional features contain actual data implementations.
   *
   * @class standard feature: annotations
   */

  /*

  Scans a template to produce an annotation map that stores expression metadata
  and information that associates the metadata to nodes in a template instance.

  Supported annotations are:

    * id attributes
    * binding annotations in text nodes
      * double-mustache expressions: {{expression}}
      * double-bracket expressions: [[expression]]
    * binding annotations in attributes
      * attribute-bind expressions: name="{{expression}} || [[expression]]"
      * property-bind expressions: name*="{{expression}} || [[expression]]"
      * property-bind expressions: name:="expression"
    * event annotations
      * event delegation directives: on-<eventName>="expression"

  Generated data-structure:

    [
      {
        id: '<id>',
        events: [
          {
            mode: ['auto'|''],
            name: '<name>'
            value: '<expression>'
          }, ...
        ],
        bindings: [
          {
            kind: ['text'|'attribute'|'property'],
            mode: ['auto'|''],
            name: '<name>'
            value: '<expression>'
          }, ...
        ],
        // TODO(sjmiles): confusingly, this is annotation-parent, not node-parent
        parent: <reference to parent annotation>,
        index: <integer index in parent's childNodes collection>
      },
      ...
    ]

  TODO(sjmiles): this module should produce either syntactic metadata
  (e.g. double-mustache, double-bracket, star-attr), or semantic metadata
  (e.g. manual-bind, auto-bind, property-bind). Right now it's half and half.

  */

  // construct `$` map (from id annotations)
  function applyIdToMap(inst, map, dom, note) {
    if (note.id) {
      map[note.id] = inst._findTemplateAnnotatedNode(dom, note);
    }
  }

  // install event listeners (from event annotations)
  function applyEventListener(inst, dom, note, host) {
    if (note.events && note.events.length) {
      var node = inst._findTemplateAnnotatedNode(dom, note);
      for (var j=0, e$=note.events, e; (j<e$.length) && (e=e$[j]); j++) {
        inst._addMethodEventListenerToNode(node, e.name, e.value, host);
      }
    }
  }

  // push configuration references at configure time
  function applyTemplateContent(inst, dom, note) {
    if (note.templateContent) {
      var node = inst._findTemplateAnnotatedNode(dom, note);
      node._content = note.templateContent;
    }
  }

  Polymer.TemplateStamp = Polymer.Utils.dedupingMixin(function(superClass) {

    return class TemplateStamp extends Polymer.Annotations(Polymer.EventListeners(superClass)) {

      constructor() {
        super();
        this.$ = null;
      }

      _stampTemplate(template) {
        // Polyfill support: bootstrap the template if it has not already been
        if (template && !template.content &&
            window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template);
        }
        var notes = this._parseTemplateAnnotations(template);
        var dom = document.importNode(template._content || template.content, true);
        // NOTE: ShadyDom optimization indicating there is an insertion point
        dom.__noInsertionPoint = !notes._hasInsertionPoint;
        this.$ = {};
        for (var i=0, l=notes.length, note; (i<l) && (note=notes[i]); i++) {
          applyIdToMap(this, this.$, dom, note);
          applyTemplateContent(this, dom, note);
          applyEventListener(this, dom, note, this);
        }
        return dom;
      }

    }

  });

})();
</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><!-- for notify, reflect -->
<!-- for annotated effects -->
<!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>

  Polymer.Path = {

    isPath: function(path) {
      return path.indexOf('.') >= 0;
    },

    root: function(path) {
      var dotIndex = path.indexOf('.');
      if (dotIndex === -1) {
        return path;
      }
      return path.slice(0, dotIndex);
    },

    isDeep: function(path) {
      return path.indexOf('.') !== -1;
    },

    // Given `base` is `foo.bar`, `foo` is an ancestor, `foo.bar` is not
    isAncestor: function(base, path) {
      //     base.startsWith(path + '.');
      return base.indexOf(path + '.') === 0;
    },

    // Given `base` is `foo.bar`, `foo.bar.baz` is an descendant
    isDescendant: function(base, path) {
      //     path.startsWith(base + '.');
      return path.indexOf(base + '.') === 0;
    },

    // can be read as:  from  to       path
    translate: function(base, newBase, path) {
      // Defense?
      return newBase + path.slice(base.length);
    },

    matches: function(base, path) {
      return (base === path) ||
             this.isAncestor(base, path) ||
             this.isDescendant(base, path);
    },

    // Converts array-based paths to flattened path, optionally split into array
    normalize: function(path, split) {
      if (Array.isArray(path)) {
        var parts = [];
        for (var i=0; i<path.length; i++) {
          var args = path[i].toString().split('.');
          for (var j=0; j<args.length; j++) {
            parts.push(args[j]);
          }
        }
        return split ? parts : parts.join('.');
      } else {
        return split ? path.toString().split('.') : path;
      }
    },

    get: function(root, path, info) {
      var prop = root;
      var parts = this.normalize(path, true);
      // Loop over path parts[0..n-1] and dereference
      for (var i=0; i<parts.length; i++) {
        if (!prop) {
          return;
        }
        var part = parts[i];
        prop = prop[part];
      }
      if (info) {
        info.path = parts.join('.');
      }
      return prop;
    },

    set: function(root, path, value) {
      var prop = root;
      var parts = this.normalize(path, true);
      var last = parts[parts.length-1];
      if (parts.length > 1) {
        // Loop over path parts[0..n-2] and dereference
        for (var i=0; i<parts.length-1; i++) {
          var part = parts[i];
          prop = prop[part];
          if (!prop) {
            return;
          }
        }
        // Set value to object at end of path
        prop[last] = value;
      } else {
        // Simple property set
        prop[path] = value;
      }
      return parts.join('.');
    }

  };

</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
(function() {

  'use strict';

  // Save map of native properties; this forms a blacklist or properties
  // that won't have their values "saved" by `saveAccessorValue`, since
  // reading from an HTMLElement accessor from the context of a prototype throws
  const nativeProperties = {};
  let proto = HTMLElement.prototype;
  while (proto) {
    let props = Object.getOwnPropertyNames(proto);
    for (let i=0; i<props.length; i++) {
      nativeProperties[props[i]] = true;
    }
    proto = Object.getPrototypeOf(proto);
  }

  /**
   * Used to save the value of a property that will be overridden with
   * an accessor. If the `model` is a prototype, the values will be saved
   * in `__dataProto`, and it's up to the user (or downstream mixin) to
   * decide how/when to set these values back into the accessors.
   * If `model` is already an instance (it has a `__data` property), then
   * the value will be set as a pending property, meaning the user should
   * call `_invalidateProperties` or `_flushProperties` to take effect
   *
   * @param {Object} model Prototype or instance
   * @param {string} property Name of property
   * @private
   */
  function saveAccessorValue(model, property) {
    // Don't read/store value for any native properties since they could throw
    if (!nativeProperties[property]) {
      let value = model[property];
      if (value !== undefined) {
        if (model.__data) {
          // Adding accessor to instance; update the property
          // It is the user's responsibility to call _flushProperties
          model._setPendingProperty(property, value);
        } else {
          // Adding accessor to proto; save proto's value for instance-time use
          if (!model.__dataProto) {
            model.__dataProto = {};
          } else if (!model.hasOwnProperty('__dataProto')) {
            model.__dataProto = Object.create(model.__dataProto);
          }
          model.__dataProto[property] = value;          
        }
      }      
    }
  }

  Polymer.PropertyAccessors = Polymer.Utils.dedupingMixin(function(superClass) {

    return class PropertyAccessors extends superClass {

      constructor() {
        super();
        this._initializeProperties();
      }

      /**
       * Initializes the local storage for property accessors.
       *
       * Override to initialize with e.g. default values by setting values into
       * accessors.
       *
       * @protected
       */
      _initializeProperties() {
        this.__data = {};
        this.__dataCounter = 0;
        this.__dataPending = null;
        this.__dataOld = null;
        this.__dataInvalid = false;
      }

      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.  When calling on
       * a prototype, any overwritten values are saved in `__dataProto`,
       * and it is up to the subclasser to decide how/when to set those
       * properties back into the accessor.  When calling on an instance,
       * the overwritten value is set via `_setPendingProperty`, and the
       * user should call `_invalidateProperties` or `_flushProperties`
       * for the values to take effect.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @protected
       */
      _createPropertyAccessor(property, readOnly) {
        saveAccessorValue(this, property);
        Object.defineProperty(this, property, {
          get: function() {
            return this.__data && this.__data[property];
          },
          set: readOnly ? function() { } : function(value) {
            this._setProperty(property, value);
          }
        });
      }

      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }

      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @protected
       */
      _setPendingProperty(property, value) {
        let old = this.__data[property];
        if (this._shouldPropertyChange(property, value, old)) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
          return true;
        }
      }

      /**
       * Returns true if the specified property has a pending change.
       *
       * @param {string} prop Property name
       * @return {boolean} True if property has a pending change
       * @protected
       */
      _isPropertyPending(prop) {
        return this.__dataPending && (prop in this.__dataPending);
      }

      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @protected
       */
      _invalidateProperties() {
        if (!this.__dataInvalid) {
          this.__dataInvalid = true;
          Promise.resolve().then(() => {
            if (this.__dataInvalid) {
              this.__dataInvalid = false;
              this._flushProperties();
            }
          });
        }
      }

      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes.
       *
       * @protected
       */
      _flushProperties() {
        let oldProps = this.__dataOld;
        let changedProps = this.__dataPending;
        this.__dataPending = null;
        this.__dataCounter++;
        this._propertiesChanged(this.__data, changedProps, oldProps);
        this.__dataCounter--;
      }

      /**
       * Callback called when any properties with accessors created via 
       * `_createPropertyAccessor` have been set.
       *
       * @param {Object} currentProps Bag of all current accessor values
       * @param {Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @protected
       */
      _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
      }

      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` for primitive types if a
       * strict equality check fails, and returns `true` for all Object/Arrays.
       * The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {type} name Description
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       */
      _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check for primitives
          (old !== value && 
           // This ensures (old==NaN, value==NaN) always returns false
           (old === old || value === value))
        );
      }

    }

  });

})();
</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
(function() {

  'use strict';

  var caseMap = Polymer.CaseMap;

  Polymer.Attributes = Polymer.Utils.dedupingMixin(function(superClass) {

    return class Attributes extends superClass {

      constructor() {
        super();
        this.__serializing = false;
      }

      /**
       * Ensures the element has the given attribute. If it does not,
       * assigns the given value to the attribute.
       *
       *
       * @method _ensureAttribute
       * @param {string} attribute Name of attribute to ensure is set.
       * @param {string} value of the attribute.
       */
      _ensureAttribute(attribute, value) {
        if (!this.hasAttribute(attribute)) {
          this._valueToNodeAttribute(this, value, attribute);
        }
      }

      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeAttribute` method to convert the string to
       * a typed value.
       *
       * @method _attributeToProperty
       * @param {string} attribute Name of attribute to deserialize.
       * @param {string} value of the attribute.
       * @param {*} type type to deserialize to.
       */
      _attributeToProperty(attribute, value, type) {
        // Don't deserialize back to property if currently reflecting
        if (!this.__serializing) {
          var property = caseMap.dashToCamelCase(attribute);
          this[property] = this._deserializeAttribute(value, type);
        }
      }

      /**
       * Serializes a property to its associated attribute.
       *
       * @method _propertyToAttribute
       * @param {string} property Property name to reflect.
       * @param {*=} attribute Attribute name to reflect.
       * @param {*=} value Property value to refect.
       */
      _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = (arguments.length < 3) ? this[property] : value;
        this._valueToNodeAttribute(this, value,
          attribute || caseMap.camelToDashCase(property));
        this.__serializing = false;
      }

      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeAttribute` method to convert the typed
       * value to a string.  If the `_serializeAttribute` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @method _valueToAttribute
       * @param {Element=} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.

       */
      _valueToNodeAttribute(node, value, attribute) {
        var str = this._serializeAttribute(value);
        if (str === undefined) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(attribute, str);
        }
      }

      /**
       * Converts a typed value to a string.
       *
       * This method is called by Polymer when setting JS property values to
       * HTML attributes.  Users may override this method on Polymer element
       * prototypes to provide serialization for custom types.
       *
       * @method _serializeAttribute
       * @param {*} value Property value to serialize.
       * @return {string} String serialized from the provided property value.
       */
      _serializeAttribute(value) {
        /* eslint-disable no-fallthrough */
        switch (typeof value) {
          case 'boolean':
            return value ? '' : undefined;

          case 'object':
            if (value instanceof Date) {
              return value;
            } else if (value) {
              try {
                return JSON.stringify(value);
              } catch(x) {
                return '';
              }
            }

          default:
            return value != null ? value : undefined;
        }
      }

      /**
       * Converts a string to a typed value.
       *
       * This method is called by Polymer when reading HTML attribute values to
       * JS properties.  Users may override this method on Polymer element
       * prototypes to provide deserialization for custom `type`s.  Note,
       * the `type` argument is the value of the `type` field provided in the
       * `properties` configuration object for a given property, and is
       * by convention the constructor for the type to deserialize.
       *
       * Note: The return value of `undefined` is used as a sentinel value to
       * indicate the attribute should be removed.
       *
       * @method _deserializeAttribute
       * @param {string} value Attribute value to deserialize.
       * @param {*} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       */
      _deserializeAttribute(value, type) {
        switch (type) {
          case Number:
            value = Number(value);
            break;

          case Boolean:
            value = (value !== null);
            break;

          case Object:
            try {
              value = JSON.parse(value);
            } catch(x) {
              // allow non-JSON literals like Strings and Numbers
            }
            break;

          case Array:
            try {
              value = JSON.parse(value);
            } catch(x) {
              value = null;
              console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
            }
            break;

          case Date:
            value = new Date(value);
            break;

          case String:
          default:
            break;
        }
        return value;
      }
      /* eslint-enable no-fallthrough */
    }

  });


})();
</script><script>
(function() {

  'use strict';

  const CaseMap = Polymer.CaseMap;
  const mixin = Polymer.Utils.mixin;

  // Monotonically increasing unique ID used for de-duping effects triggered
  // from multiple properties in the same turn
  let effectUid = 0;

  // Property effect types; effects are stored on the prototype using these keys
  const TYPES = {
    ANY: '__propertyEffects',
    COMPUTE: '__computeEffects',
    REFLECT: '__reflectEffects',
    NOTIFY: '__notifyEffects',
    PROPAGATE: '__propagateEffects',
    OBSERVE: '__observeEffects',
    READ_ONLY: '__readOnly'
  }

  /**
   * Ensures that the model has an own-property map of effects for the given type.
   * The model may be a prototype or an instance.
   * 
   * Property effects are stored as arrays of effects by property in a map,
   * by named type on the model. e.g.
   *
   *   __computeEffects: {
   *     foo: [ ... ],
   *     bar: [ ... ]
   *   }
   *
   * If the model does not yet have an effect map for the type, one is created
   * and returned.  If it does, but it is not an own property (i.e. the
   * prototype had effects), the the map is deeply cloned and the copy is
   * set on the model and returned, ready for new effects to be added. 
   *
   * @param {Object} model Prototype or instance
   * @param {string} type Property effect type
   * @return {Object} The own-property map of effects for the given type
   * @private
   */
  function ensureOwnEffectMap(model, type) {
    let effects = model[type];
    if (!effects) {
      effects = model[type] = {};
    } else if (!model.hasOwnProperty(type)) {
      effects = model[type] = Object.create(model[type]);
      for (let p in effects) {
        // TODO(kschaaf): replace with fast array copy #!%&$!
        effects[p] = effects[p].slice();
      }
    }
    return effects;
  }

  // -- effects ----------------------------------------------

  /**
   * Runs all effects of a given type for the given set of property changes
   * on an instance.
   *
   * @param {Object} inst The instance with effects to run
   * @param {string} type Type of effect to run
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @private
   */
  function runEffects(inst, type, props, oldProps) {
    let ran;
    let effects = inst[type];
    if (effects) {
      let id = effectUid++;
      for (let prop in props) {
        if (runEffectsForProperty(inst, effects, id, prop, props[prop],
          oldProps && oldProps[prop])) {
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Runs a list of effects for a given property.
   *
   * @param {Object} inst The instance with effects to run
   * @param {Array} effects Array of effects
   * @param {number} id Effect run id used for de-duping effects
   * @param {string} prop Name of changed property
   * @param {*} value Value of changed property
   * @param {*} old Previous value of changed property
   * @private
   */
  function runEffectsForProperty(inst, effects, id, prop, value, old) {
    let ran;
    // TODO(kschaaf) ideally a system exists to parse path information once
    // and send structured information through the system for better perf
    let rootProperty = Polymer.Path.root(prop);
    let fxs = effects[rootProperty];
    if (fxs) {
      let fromAbove = inst.__dataFromAbove;
      for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
        if (Polymer.Path.matches(fx.path, prop) &&
          (!fx.info || fx.info.lastRun !== id)) {
          if (rootProperty !== prop) {
            // Pull the latest path value to pass to effect
            let v = Polymer.Path.get(inst, prop);
            // Fall back to the original changed value; this is mostly to thread
            // array.splices through without it actually being on the array
            if (v === undefined) {
              v = value;
            }
          } else {
            // Pull the latest property value to pass to effect
            value = inst[prop];
          }
          fx.fn(inst, prop, value, old, fx.info, fromAbove);
          if (fx.info) {
            fx.info.lastRun = id;
          }
          ran = true;
        }
      }
    }
    return ran;
  }

  /**
   * Implements the "observer" effect.
   *
   * Calls the method with `info.methodName` on the instance, passing the
   * new and old values.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runObserverEffect(inst, property, value, old, info) {
    let fn = inst[info.methodName];
    if (fn) {
      fn.call(inst, value, old);
    } else {
      console.warn('observer method `' + info.methodName + '` not defined');
    }
  }

  /**
   * Runs "notify" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * will dispatch path notification events in the case that the property
   * changed was a path and the root property for that path didn't have a
   * "notify" effect.  This is to maintain 1.0 behavior that did not require
   * `notify: true` to ensure object sub-property notifications were
   * sent.
   *
   * @param {Object} inst The instance with effects to run
   * @param {Object} props Bag of current property changes
   * @param {Object} oldProps Bag of previous values for changed properties
   * @private
   */
  function runNotifyEffects(inst, props, oldProps) {
    // Notify
    let notified;
    let notifyEffects = inst[TYPES.NOTIFY];
    let id = effectUid++;
    // Try normal notify effects; if none, fall back to try path notification
    // TODO(kschaaf) This is a hot path which we could avoid if (1) no
    // "notify" effects AND (2) if we knew there were no paths to notify. This
    // 2nd piece of info is not currently available but could be added perhaps
    // in `_setProperty`.
    for (let prop in props) {
      if (notifyEffects && runEffectsForProperty(inst, notifyEffects, id,
        prop, props[prop], oldProps && oldProps[prop])) {
        notified = true;
      } else if (notifyPath(inst, prop, props[prop])) {
        notified = true;
      }
    }
    // Flush host if we actually notified and host was batching
    let host;
    if (notified && (host = inst.__dataHost) && host.setProperties) {
      host._flushProperties();
    }
  }

  /**
   * Dispatches {property}-changed events with path information in the detail 
   * object to indicate a sub-path of the property was changed.
   *
   * @param {Element} inst The element from which to fire the event
   * @param {string} path The path that was changed
   * @private
   */
  function notifyPath(inst, path, value) {
    let rootProperty = Polymer.Path.root(path);
    if (rootProperty !== path) {
      let eventName = Polymer.CaseMap.camelToDashCase(rootProperty) + '-changed';
      dispatchNotifyEvent(inst, eventName, value, path);
      return true;
    }
  }

  /**
   * Dispatches {property}-changed events to indicate a property (or path)
   * changed.
   *
   * @param {Element} inst The element from which to fire the event
   * @param {string} eventName The name of the event to send ('{property}-changed')
   * @param {*} value The value of the changed property
   * @param {string=} path If a sub-path of this property changed, the path
   *   that changed (optional).
   * @private
   */
  function dispatchNotifyEvent(inst, eventName, value, path) {
    let detail = {
      value: value,
      queueProperty: true
    };
    if (path) {
      detail.path = path;
    }
    inst.dispatchEvent(new CustomEvent(eventName, { detail }));
  }

  /**
   * Implements the "notify" effect.
   *
   * Dispatches a non-bubbling event named `info.eventName` on the instance
   * with a detail object containing the new `value`.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runNotifyEffect(inst, property, value, old, info) {
    let rootProperty = Polymer.Path.root(property);
    let path = rootProperty != property ? property : null;
    dispatchNotifyEvent(inst, info.eventName, value, path);
  }

  /**
   * Adds a 2-way binding notification event listener to the node specified
   *
   * @param {Object} node Child element to add listener to
   * @param {Object} inst Host element instance to handle notification event
   * @param {Object} info Listener metadata stored via addAnnotatedListener
   * @private
   */
  function addNotifyListener(node, inst, info) {
    node.addEventListener(info.event, function(e) {
      handleNotification(e, inst, info.property, info.path, info.negate);
    });
  }

  /**
   * Handler function for 2-way notification events. Receives context
   * information captured in the `addNotifyListener` closure from the
   * `_bindListeners` metadata.
   *
   * Sets the value of the notified property to the host property or path.  If
   * the event contained path information, translate that path to the host
   * scope's name for that path first.
   *
   * @param {Event} e Notification event (e.g. '<property>-changed')
   * @param {Object} inst Host element instance handling the notification event
   * @param {string} property Child element property that was bound
   * @param {string} path Host property/path that was bound 
   * @param {boolean} negate Whether the binding was negated
   * @private
   */
  function handleNotification(e, inst, property, path, negate) {
    let value;
    let targetPath = e.detail && e.detail.path;
    if (targetPath) {
      path = Polymer.Path.translate(property, path, targetPath);
      value = e.detail && e.detail.value;
    } else {
      value = e.target[property];
    }
    value = negate ? !value : value;
    setPropertyFromNotification(inst, path, value, e);
  }

  /**
   * Called by 2-way binding notification event listeners to set a property
   * or path to the host based on a notification from a bound child.
   *
   * @param {string} path Path on this instance to set
   * @param {*} value Value to set to given path
   * @protected
   */
  function setPropertyFromNotification(inst, path, value, event) {
    let detail = event.detail;
    if (detail && detail.queueProperty) {
      if (!inst._hasReadOnlyEffect(path)) {
        if ((path = inst._setPathOrUnmanagedProperty(path, value, Boolean(detail.path)))) {
          inst._setPendingProperty(path, value);
        }
      }
    } else {
      inst.set(path, value);
    }
  }

  /**
   * Implements the "reflect" effect.
   *
   * Sets the attribute named `info.attrName` to the given property value.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runReflectEffect(inst, property, value, old, info) {
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.attrName, 'attribute', inst);
    }
    inst._propertyToAttribute(property, info.attrName, value);
  }

  /**
   * Implements the "method observer" effect by running the method with the
   * values of the arguments specified in the `info` object.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runMethodObserverEffect(inst, property, value, old, info) {
    runMethodEffect(inst, property, value, old, info);
  }

  /**
   * Runs "computed" effects for a set of changed properties.
   *
   * This method differs from the generic `runEffects` method in that it
   * continues to run computed effects based on the output of each pass until
   * there are no more newly computed properties.  This ensures that all
   * properties that will be computed by the initial set of changes are
   * computed before other effects (binding propagation, observers, and notify)
   * run.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {Object} changedProps Bag of changed properties
   * @param {Object} oldProps Bag of previous values for changed properties
   * @return {Object} Bag of newly computed properties from "computed" effects
   */
  function runComputedEffects(inst, changedProps, oldProps) {
    if (inst[TYPES.COMPUTE]) {
      let inputProps = changedProps;
      let computedProps;
      while (runEffects(inst, TYPES.COMPUTE, inputProps)) {
        mixin(oldProps, inst.__dataOld);
        mixin(changedProps, inst.__dataPending);
        computedProps = mixin(computedProps || {}, inst.__dataPending);
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
      return computedProps;
    }
  }

  /**
   * Implements the "computed property" effect by running the method with the
   * values of the arguments specified in the `info` object and setting the
   * return value to the computed property specified.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runComputedEffect(inst, property, value, old, info) {
    var result = runMethodEffect(inst, property, value, old, info);
    var computedProp = info.methodInfo;
    if (inst._hasPropertyEffect(computedProp)) {
      inst._setPendingProperty(computedProp, result);
    } else {
      inst[computedProp] = result;
    }
  }

  /**
   * Computes path changes based on path links set up using the `linkPaths`
   * API.
   *
   * @param {Object} inst The instance whose props are changing
   * @param {Object} changedProps Bag of changed properties
   * @param {Object} computedProps Bag of properties newly computed this turn
   *   via "computed" effects; any linked paths generated via this method
   *   will be added both to the set of `changedProps` as well as to the
   *   set of `computedProps`; this is because the `fromAbove: true` case will 
   *   notify only from the `computedProps` bag.
   * @private
   */
  function computeLinkedPaths(inst, changedProps, computedProps) {
    const links = inst.__dataLinkedPaths;
    const cache = inst.__dataTemp;
    if (links) {
      computedProps = computedProps || {};
      let link;
      for (let a in links) {
        let b = links[a];
        for (let path in changedProps) {
          if (Polymer.Path.isDescendant(a, path)) {
            link = Polymer.Path.translate(a, b, path);
            cache[link] = changedProps[link] = computedProps[link] = changedProps[path];
          } else if (Polymer.Path.isDescendant(b, path)) {
            link = Polymer.Path.translate(b, a, path);
            cache[link] = changedProps[link] = computedProps[link] = changedProps[path];
          }
        }
      }
    }
    return computedProps;
  }

  // -- bindings ----------------------------------------------

  /**
   * Adds "binding" property effects for the template annotation
   * ("note" for short) and node index specified.  These may either be normal
   * "binding" effects (property/path bindings) or "method binding"
   * effects, aka inline computing functions, depending on the type of binding
   * detailed in the note.
   *
   * @param {Object} model Prototype or instance
   * @param {Object} note Annotation note returned from Annotator
   * @param {number} index Index into `__dataNodes` list of annotated nodes that the
   *   note applies to
   * @private
   */
  function addBindingEffect(model, note, index) {
    for (let i=0; i<note.parts.length; i++) {
      let part = note.parts[i];
      if (part.signature) {
        addMethodBindingEffect(model, note, part, index);
      } else if (!part.literal) {
        if (note.kind === 'attribute' && note.name[0] === '-') {
          console.warn('Cannot set attribute ' + note.name +
            ' because "-" is not a valid attribute starting character');
        } else {
          model._addPropertyEffect(part.value, TYPES.PROPAGATE, {
            fn: runBindingEffect,
            info:  {
              kind: note.kind,
              index: index,
              name: note.name,
              propertyName: note.propertyName,
              value: part.value,
              isCompound: note.isCompound,
              compoundIndex: part.compoundIndex,
              event: part.event,
              customEvent: part.customEvent,
              negate: part.negate
            }
          });
        }
      }
    }
  }

  /**
   * Implements the "binding" (property/path binding) effect.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runBindingEffect(inst, path, value, old, info) {
    let node = inst.__dataNodes[info.index];
    // Subpath notification: transform path and set to client
    // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
    if ((path.length > info.value.length) &&
        (info.kind == 'property') && !info.isCompound &&
        node._hasPropertyEffect && node._hasPropertyEffect(info.name)) {
      path = Polymer.Path.translate(info.value, info.name, path);
      setPropertyToNodeFromBinding(inst, node, path, value);
    } else {
      // Root or deeper path was set; extract bound path value
      // e.g.: foo="{{obj.sub}}", path: 'obj', set 'foo'=obj.sub
      //   or: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo'=obj.sub
      if (path != info.value) {
        value = Polymer.Path.get(inst, info.value);
      }
      // Propagate value to child
      applyBindingValue(inst, info, value);
    }
  }

  /**
   * Called by "binding effect" to set a property to a node.  Note,
   * the caller must ensure that the target node has a property effect for
   * the property in question, otherwise this method will error.
   *
   * @param {Node} node Node to set property on
   * @param {string} prop Property (or path) name to set
   * @param {*} value Value to set
   * @protected
   */
  function setPropertyToNodeFromBinding(inst, node, prop, value) {
    if (!node._hasReadOnlyEffect(prop)) {
      if (node._setPendingProperty(prop, value)) {
        inst._enqueueClient(node);
      }
    }
  }

  /**
   * Sets the value for an "binding" (binding) effect to a node,
   * either as a property or attribute.
   *
   * @param {Object} inst The instance owning the binding effect
   * @param {Object} info Effect metadata
   * @param {*} value Value to set
   * @private
   */
  function applyBindingValue(inst, info, value) {
    let node = inst.__dataNodes[info.index];
    value = computeBindingValue(node, value, info);
    if (Polymer.sanitizeDOMValue) {
      value = Polymer.sanitizeDOMValue(value, info.name, info.kind, node);
    }
    if (info.kind == 'attribute') {
      // Attribute binding
      inst._valueToNodeAttribute(node, value, info.name);
    } else {
      // Property binding
      let prop = info.name;
      if (node._hasPropertyEffect && node._hasPropertyEffect(prop)) {
        setPropertyToNodeFromBinding(inst, node, prop, value);
      // The `else` clause is for interop: binding to a non-Polymer element's
      // property. Some native element properties have side-effects when
      // re-setting the same value (e.g. setting <input>.value resets the
      // cursor position), so we do a dirty-check before setting the value.
      // However, for better interop with non-Polymer custom elements that
      // accept objects, we explicitly re-set object changes coming from the
      // Polymer world (which may include deep object changes without the
      // top reference changing), erring on the side of providing more
      // information. It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      } else if (value !== node[prop] || typeof value == 'object') {
        node[prop] = value;
      }
    }
  }

  /**
   * Transforms an "binding" effect value based on compound & negation
   * effect metadata, as well as handling for special-case properties
   *
   * @param {Node} node Node the value will be set to
   * @param {*} value Value to set
   * @param {Object} info Effect metadata
   * @return {*} Transformed value to set
   * @private
   */
  function computeBindingValue(node, value, info) {
    if (info.negate) {
      value = !value;
    }
    if (info.isCompound) {
      let storage = node.__dataCompoundStorage[info.name];
      storage[info.compoundIndex] = value;
      value = storage.join('');
    }
    if (info.kind !== 'attribute') {
      // Some browsers serialize `undefined` to `"undefined"`
      if (info.name === 'textContent' ||
          (node.localName == 'input' && info.name == 'value')) {
        value = value == undefined ? '' : value;
      }
    }
    return value;
  }

  /**
   * Adds "binding method" property effects for the template binding
   * ("note" for short), part metadata, and node index specified.
   *
   * @param {Object} model Prototype or instance
   * @param {Object} note Binding note returned from Annotator
   * @param {number} part The compound part metadata
   * @param {number} index Index into `__dataNodes` list of annotated nodes that the
   *   note applies to
   * @private
   */
  function addMethodBindingEffect(model, note, part, index) {
    createMethodEffect(model, part.signature, TYPES.PROPAGATE,
      runMethodBindingEffect, {
        index: index,
        isCompound: note.isCompound,
        compoundIndex: part.compoundIndex,
        kind: note.kind,
        name: note.name,
        negate: part.negate,
        part: part
      }, true
    );
  }

  /**
   * Implements the "binding method" (inline computed function) effect.
   *
   * Runs the method with the values of the arguments specified in the `info`
   * object and setting the return value to the node property/attribute.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runMethodBindingEffect(inst, property, value, old, info) {
    let val = runMethodEffect(inst, property, value, old, info);
    applyBindingValue(inst, info.methodInfo, val);
  }

  /**
   * Post-processes template bindings (notes for short) provided by the
   * Bindings library for use by the effects system:
   * - Parses bindings for methods into method `signature` objects
   * - Memoizes the root property for path bindings
   * - Recurses into nested templates and processes those templates and
   *   extracts any host properties, which are set to the template's
   *   `_content._hostProps` 
   * - Adds bindings from the host to <template> elements for any nested
   *   template's lexically bound "host properties"; template handling
   *   elements can then add accessors to the template for these properties
   *   to forward host properties into template instances accordingly.
   *
   * @param {Array<Object>} notes List of notes to process; the notes are
   *   modified in place.
   * @private
   */
  function processAnnotations(notes) {
    if (!notes._processed) {
      for (let i=0; i<notes.length; i++) {
        let note = notes[i];
        // Parse bindings for methods & path roots (models)
        for (let j=0; j<note.bindings.length; j++) {
          let b = note.bindings[j];
          for (let k=0; k<b.parts.length; k++) {
            let p = b.parts[k];
            if (!p.literal) {
              p.signature = parseMethod(p.value);
              if (!p.signature) {
                p.rootProperty = Polymer.Path.root(p.value);
              }
            }
          }
        }
        // Recurse into nested templates & bind host props
        if (note.templateContent) {
          processAnnotations(note.templateContent._notes);
          let hostProps = note.templateContent._hostProps =
            discoverTemplateHostProps(note.templateContent._notes);
          let bindings = [];
          for (let prop in hostProps) {
            bindings.push({
              index: note.index,
              kind: 'property',
              name: '_host_' + prop,
              parts: [{
                mode: '{',
                rootProperty: prop,
                value: prop
              }]
            });
          }
          note.bindings = note.bindings.concat(bindings);
        }
      }
      notes._processed = true;
    }
  }

  /**
   * Finds all property usage in templates (property/path bindings and function
   * arguments) and returns the path roots as keys in a map. Each outer template
   * merges inner _hostProps to propagate inner host property needs to outer
   * templates.
   *
   * @param {Array<Object>} notes List of notes to process for a given template
   * @return {Object<string,boolean>} Map of host properties that the template
   *   (or any nested templates) uses
   * @private
   */
  function discoverTemplateHostProps(notes) {
    let hostProps = {};
    for (let i=0, n; (i<notes.length) && (n=notes[i]); i++) {
      // Find all bindings to parent.* and spread them into _parentPropChain
      for (let j=0, b$=n.bindings, b; (j<b$.length) && (b=b$[j]); j++) {
        for (let k=0, p$=b.parts, p; (k<p$.length) && (p=p$[k]); k++) {
          if (p.signature) {
            let args = p.signature.args;
            for (let kk=0; kk<args.length; kk++) {
              let rootProperty = args[kk].rootProperty;
              if (rootProperty) {
                hostProps[rootProperty] = true;
              }
            }
            hostProps[p.signature.methodName] = true;
          } else {
            if (p.rootProperty) {
              hostProps[p.rootProperty] = true;
            }
          }
        }
      }
      // Merge child _hostProps into this _hostProps
      if (n.templateContent) {
        let templateHostProps = n.templateContent._hostProps;
        Polymer.Base.mixin(hostProps, templateHostProps);
      }
    }
    return hostProps;
  }

  /**
   * Returns true if a binding's metadata meets all the requirements to allow
   * 2-way binding, and therefore a <property>-changed event listener should be
   * added:
   * - used curly braces
   * - is a property (not attribute) binding
   * - is not a textContent binding
   * - is not compound
   *
   * @param {Object} binding Binding metadata
   * @return {boolean} True if 2-way listener should be added
   * @private
   */
  function shouldAddListener(binding) {
    return binding.name &&
           binding.kind != 'attribute' &&
           binding.kind != 'text' &&
           !binding.isCompound &&
           binding.parts[0].mode === '{';
  }

  /**
   * Sets up a prototypical `_bindListeners` metadata array to be used at
   * instance time to add event listeners for 2-way bindings.
   *
   * @param {Object} model Prototype (instances not currently supported)
   * @param {number} index Index into `__dataNodes` list of annotated nodes that the
   *   event should be added to
   * @param {string} property Property of target node to listen for changes
   * @param {string} path Host path that the change should be propagated to
   * @param {string=} event A custom event name to listen for (e.g. via the
   *   `{{prop::eventName}}` syntax)
   * @param {boolean=} negate Whether the notified value should be negated before
   *   setting to host path
   * @private
   */
  function addAnnotatedListener(model, index, property, path, event, negate) {
    if (!model._bindListeners) {
      model._bindListeners = [];
    }
    let eventName = event ||
      (CaseMap.camelToDashCase(property) + '-changed');
    model._bindListeners.push({
      index: index,
      property: property,
      path: path,
      event: eventName,
      negate: negate
    });
  }

  /**
   * Adds all 2-way binding notification listeners to a host based on
   * `_bindListeners` metadata recorded by prior calls to`addAnnotatedListener`
   *
   * @param {Object} inst Host element instance
   * @private
   */
  function setupBindListeners(inst) {
    let b$ = inst._bindListeners;
    for (let i=0, l=b$.length, info; (i<l) && (info=b$[i]); i++) {
      let node = inst.__dataNodes[info.index];
      addNotifyListener(node, inst, info);
    }
  }

  /**
   * Finds all bound nodes in the given `dom` fragment that were recorded in the
   * provided Annotator `notes` array and stores them in `__dataNodes` for this
   * instance.  The index of nodes in `__dataNodes` corresponds to the index
   * of a note in the `notes` array, and binding effect metadata uses this
   * index to identify bound nodes when propagating data.
   *
   * Compound binding storage structures are also initialized onto the bound
   * nodes, and 2-way binding event listeners are also added.
   *
   * @param {Object} inst Instance that bas been previously bound
   * @param {DocumentFragment} dom Document fragment containing stamped nodes
   * @param {Array<Object>} notes Array of annotation notes provided by
   *   Polymer.Annotator
   * @private
   */
  function setupBindings(inst, dom, notes) {
    if (notes.length) {
      let nodes = new Array(notes.length);
      for (let i=0; i < notes.length; i++) {
        let note = notes[i];
        let node = nodes[i] = inst._findTemplateAnnotatedNode(dom, note);
        node.__dataHost = inst;
        if (note.bindings) {
          setupCompoundBinding(note, node);
        }
      }
      inst.__dataNodes = nodes;
    }
    if (inst._bindListeners) {
      setupBindListeners(inst);
    }
  }

  // -- for method-based effects (complexObserver & computed) --------------

  /**
   * Adds property effects for each argument in the method signature (and
   * optionally, for the method name if `dynamic` is true) that calls the
   * provided effect function.
   *
   * @param {Object} inst Prototype or instance
   * @param {Object} sig Method signature metadata
   * @param {Function} effectFn Function to run when arguments change
   * @param {boolean=} dynamic Whether the method name should be included as
   *   a dependency to the effect.
   * @private
   */
  function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamic) {
    let info = {
      methodName: sig.methodName,
      args: sig.args,
      methodInfo: methodInfo,
      dynamicFn: dynamic
    };
    // TODO(sorvell): why still here?
    if (sig.static) {
      model._addPropertyEffect('__static__', type, {
        fn: effectFn, info: info
      });
    } else {
      for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
        if (!arg.literal) {
          model._addPropertyEffect(arg.name, type, {
            fn: effectFn, info: info
          });
        }
      }
    }
    if (dynamic) {
      model._addPropertyEffect(sig.methodName, type, {
        fn: effectFn, info: info
      });
    }
  }

  /**
   * Calls a method with arguments marshaled from properties on the instance
   * based on the method signature contained in the effect metadata.
   *
   * Multi-property observers, computed properties, and inline computing
   * functions call this function to invoke the method, then use the return
   * value accordingly.
   *
   * @param {Object} inst The instance the effect will be run on
   * @param {string} property Name of property
   * @param {*} value Current value of property
   * @param {*} old Previous value of property
   * @param {Object} info Effect metadata
   * @private
   */
  function runMethodEffect(inst, property, value, old, info) {
    // TODO(kschaaf): ideally rootDataHost would be a detail of Templatizer only
    let context = inst._rootDataHost || inst;
    let fn = context[info.methodName];
    if (fn) {
      let args = marshalArgs(inst.__data, info.args, property, value);
      return fn.apply(context, args);
    } else if (!info.dynamicFn) {
      console.warn('method `' + info.methodName + '` not defined');
    }
  }

  const emptyArray = [];

  /**
   * Parses an expression string for a method signature, and returns a metadata
   * describing the method in terms of `methodName`, `static` (whether all the
   * arguments are literals), and an array of `args`
   *
   * @param {string} expression The expression to parse
   * @return {?Object} The method metadata object if a method expression was
   *   found, otherwise `undefined`
   * @private
   */
  function parseMethod(expression) {
    // tries to match valid javascript property names
    let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
    if (m) {
      let sig = { methodName: m[1], static: true };
      if (m[2].trim()) {
        // replace escaped commas with comma entity, split on un-escaped commas
        let args = m[2].replace(/\\,/g, '&comma;').split(',');
        return parseArgs(args, sig);
      } else {
        sig.args = emptyArray;
        return sig;
      }
    }
  }

  /**
   * Parses an array of arguments and sets the `args` property of the supplied
   * signature metadata object. Sets the `static` property to false if any
   * argument is a non-literal.
   *
   * @param {Array<string>} argList Array of argument names
   * @param {Object} sig Method signature metadata object
   * @return {Object} The updated signature metadata object
   * @private
   */
  function parseArgs(argList, sig) {
    sig.args = argList.map(function(rawArg) {
      let arg = parseArg(rawArg);
      if (!arg.literal) {
        sig.static = false;
      }
      return arg;
    }, this);
    return sig;
  }

  /**
   * Parses an individual argument, and returns an argument metadata object
   * with the following fields:
   *
   *   {
   *     value: 'prop',        // property/path or literal value
   *     literal: false,       // whether argument is a literal
   *     structured: false,    // whether the property is a path
   *     rootProperty: 'prop', // the root property of the path
   *     wildcard: false       // whether the argument was a wildcard '.*' path
   *   }
   *
   * @param {string} rawArg The string value of the argument
   * @return {Object} Argument metadata object
   * @private
   */
  function parseArg(rawArg) {
    // clean up whitespace
    let arg = rawArg.trim()
      // replace comma entity with comma
      .replace(/&comma;/g, ',')
      // repair extra escape sequences; note only commas strictly need
      // escaping, but we allow any other char to be escaped since its
      // likely users will do this
      .replace(/\\(.)/g, '\$1')
      ;
    // basic argument descriptor
    let a = {
      name: arg
    };
    // detect literal value (must be String or Number)
    let fc = arg[0];
    if (fc === '-') {
      fc = arg[1];
    }
    if (fc >= '0' && fc <= '9') {
      fc = '#';
    }
    switch(fc) {
      case "'":
      case '"':
        a.value = arg.slice(1, -1);
        a.literal = true;
        break;
      case '#':
        a.value = Number(arg);
        a.literal = true;
        break;
    }
    // if not literal, look for structured path
    if (!a.literal) {
      a.rootProperty = Polymer.Path.root(arg);
      // detect structured path (has dots)
      a.structured = Polymer.Path.isDeep(arg);
      if (a.structured) {
        a.wildcard = (arg.slice(-2) == '.*');
        if (a.wildcard) {
          a.name = arg.slice(0, -2);
        }
      }
    }
    return a;
  }

  /**
   * Gather the argument values for a method specified in the provided array
   * of argument metadata.
   *
   * The `path` and `value` arguments are used to fill in wildcard descriptor
   * when the method is being called as a result of a path notification.
   * 
   * @param {Object} data Instance data storage object to read properties from
   * @param {Array<Object>} args Array of argument metadata
   * @return {Array<*>} Array of argument values
   * @private
   */
  function marshalArgs(data, args, path, value) {
    let values = [];
    for (let i=0, l=args.length; i<l; i++) {
      let arg = args[i];
      let name = arg.name;
      let v;
      if (arg.literal) {
        v = arg.value;
      } else if (path == name) {
        v = value;
      } else {
        // TODO(kschaaf): confirm design of this
        v = data[name];
        if (v === undefined && arg.structured) {
          v = Polymer.Path.get(data, name);
        }
      }
      if (arg.wildcard) {
        // Only send the actual path changed info if the change that
        // caused the observer to run matched the wildcard
        let baseChanged = (name.indexOf(path + '.') === 0);
        let matches = (path.indexOf(name) === 0 && !baseChanged);
        values[i] = {
          path: matches ? path : name,
          value: matches ? value : v,
          base: v
        };
      } else {
        values[i] = v;
      }
    }
    return values;
  }

  /**
   * Initializes `__dataCompoundStorage` local storage on a bound node with
   * initial literal data for compound bindings, and sets the joined
   * literal parts to the bound property.
   * 
   * When changes to compound parts occur, they are first set into the compound
   * storage array for that property, and then the array is joined to result in
   * the final value set to the property/attribute.
   *
   * @param {Object} note Annotation metadata
   * @param {Node} node Bound node to initialize
   * @private
   */
  function setupCompoundBinding(note, node) {
    let bindings = note.bindings;
    for (let i=0; i<bindings.length; i++) {
      let binding = bindings[i];
      if (binding.isCompound) {
        // Create compound storage map
        let storage = node.__dataCompoundStorage ||
          (node.__dataCompoundStorage = {});
        let parts = binding.parts;
        // Copy literals from parts into storage for this binding
        let literals = new Array(parts.length);
        for (let j=0; j<parts.length; j++) {
          literals[j] = parts[j].literal;
        }
        let name = binding.name;
        storage[name] = literals;
        // Configure properties with their literal parts
        if (binding.literal && binding.kind == 'property') {
          // TODO(kschaaf) config integration
          // if (node._configValue) {
          //   node._configValue(name, binding.literal);
          // } else {
            node[name] = binding.literal;
          // }
        }
      }
    }
  }

  // data api

  /**
   * Sends array splice notifications (`.splices` and `.length`) 
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {Object} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {Array} splices Array of splice records
   * @private
   */
  function notifySplices(inst, array, path, splices) {
    let splicesPath = path + '.splices';
    inst._setProperty(splicesPath, { indexSplices: splices });
    inst._setProperty(path + '.length', array.length);
    // Null here to allow potentially large splice records to be GC'ed.
    inst.__data[splicesPath] = {indexSplices: null};
  }

  /**
   * Creates a splice record and sends an array splice notification for
   * the described mutation
   *
   * Note: this implementation only accepts normalized paths
   *
   * @param {Object} inst Instance to send notifications to
   * @param {Array} array The array the mutations occurred on
   * @param {string} path The path to the array that was mutated
   * @param {number} index Index at which the array mutation occurred
   * @param {number} addedCount Number of added items
   * @param {Array} removed Array of removed items
   * @private
   */
  function notifySplice(inst, array, path, index, addedCount, removed) {
    notifySplices(inst, array, path, [{
      index: index,
      addedCount: addedCount,
      removed: removed,
      object: array,
      type: 'splice'
    }]);
  }

  /**
   * Returns an upper-cased version of the string.
   *
   * @param {string} name String to uppercase
   * @return {string} Uppercased string
   * @private
   */
  function upper(name) {
    return name[0].toUpperCase() + name.substring(1);
  }

  Polymer.PropertyEffects = Polymer.Utils.dedupingMixin(function(superClass) {

    return class PropertyEffects extends Polymer.TemplateStamp(
      Polymer.Attributes(Polymer.PropertyAccessors(superClass))) {

      get PROPERTY_EFFECT_TYPES() {
        return TYPES;
      }

      constructor() {
        super();
        this._asyncEffects = false;
        this.__dataInitialized = false;
        this.__dataPendingClients = null;
        this.__dataFromAbove = false;
        this.__dataLinkedPaths = null;
        this.__dataNodes = null;
        // May be set on instance prior to upgrade
        this.__dataCompoundStorage = this.__dataCompoundStorage || null;
        this.__dataHost = this.__dataHost || null;
      }

      /**
       * Adds to default initialization in `PropertyAccessors` by initializing
       * local property & pending data storage with any accessor values saved
       * in `__dataProto`.  If instance properties had been set before the
       * element upgraded and gained accessors on its prototype, these values
       * are set into the prototype's accessors after being deleted from the
       * instance.
       *
       * @override
       */
      _initializeProperties() {
        super._initializeProperties();
        this.__dataTemp = {};
        // initialize data with prototype values saved when creating accessors
        if (this.__dataProto) {
          this.__data = Object.create(this.__dataProto);
          this.__dataPending = Object.create(this.__dataProto);
          this.__dataOld = {};
        } else {
          this.__dataPending = null;
        }
        // update instance properties
        for (let p in this.__propertyEffects) {
          if (this.hasOwnProperty(p)) {
            let value = this[p];
            delete this[p];
            this[p] = value;
          }
        }
      }

      // Prototype setup ----------------------------------------

      /**
       * Ensures an accessor exists for the specified property, and adds
       * to a list of "property effects" that will run when the accessor for
       * the specified property is set.  Effects are grouped by "type", which
       * roughly corresponds to a phase in effect processing.  The effect
       * metadata should be in the following form:
       *
       *   {
       *     fn: effectFunction, // Reference to function to call to perform effect
       *     info: { ... }       // Effect metadata passed to function
       *     // path: '...'      // Will be set by this method based on path arg
       *   }
       *
       * Effect functions are called with the following signature:
       *
       *   effectFunction(inst, property, currentValue, oldValue, info)
       *
       * This method may be called either on the prototype of a class
       * using the PropertyEffects mixin (for best performance), or on
       * an instance to add dynamic effects.  When called on an instance or
       * subclass of a class that has already had property effects added to
       * its prototype, the property effect lists will be cloned and added as
       * own properties of the caller.
       *
       * @param {string} path Property (or path) that should trigger the effect
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @param {Object} effect Effect metadata object
       * @protected
       */
      _addPropertyEffect(path, type, effect) {
        let property = Polymer.Path.root(path);
        let effects = ensureOwnEffectMap(this, TYPES.ANY)[property];
        if (!effects) {
          effects = this.__propertyEffects[property] = [];
          this._createPropertyAccessor(property,
            type == TYPES.READ_ONLY);
        }
        // effects are accumulated into arrays per property based on type
        if (effect) {
          effect.path = path;
          effects.push(effect);
        }
        effects = ensureOwnEffectMap(this, type)[property];
        if (!effects) {
          effects = this[type][property] = [];
        }
        effects.push(effect);
      }

      /**
       * Returns whether the current prototype/instance has a property effect
       * of a certain type.
       *
       * @param {string} property Property name
       * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasPropertyEffect(property, type) {
        let effects = this[type || TYPES.ANY];
        return Boolean(effects && effects[property]);
      }

      /**
       * Returns whether the current prototype/instance has a "read only"
       * accessor for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasReadOnlyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.READ_ONLY);
      }

      /**
       * Returns whether the current prototype/instance has a "notify"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasNotifyEffect(property) {
        return this._hasPropertyEffect(property, TYPES.NOTIFY);
      }

      /**
       * Returns whether the current prototype/instance has a "reflect to attribute"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasReflectEffect(property) {
        return this._hasPropertyEffect(property, TYPES.REFLECT);
      }

      /**
       * Returns whether the current prototype/instance has a "computed"
       * property effect for the given property.
       *
       * @param {string} property Property name
       * @return {boolean} True if the prototype/instance has an effect of this type
       * @protected
       */
      _hasComputedEffect(property) {
        return this._hasPropertyEffect(property, TYPES.COMPUTE);
      }

      // Runtime ----------------------------------------

      /**
       * Sets an unmanaged property (property without accessor) or leaf property
       * of a path to the given value.  If the path in question was a simple
       * property with an accessor, no action is taken.
       *
       * This function isolates relatively expensive functionality necessary
       * for the public API, such that it is only done when paths enter the
       * system, and not in every step of the hot path.
       *
       * If `path` is an unmanaged property (property without an accessor)
       * or a path, sets the value at that path.
       * 
       * `path` can be a path string or array of path parts as accepted by the
       * public API.
       *
       * @param {string} path Path to set
       * @param {*} value Value to set
       * @param {boolean} fromPath If the value being set was from a path; in
       *   this case the value was shared, so no dirty check is performed.
       * @return {?string} If the root of the path is a managed property,
       *   returns a normalized string path suitable for setting into the system
       *   via `_setProperty`/`_setPendingProperty`. A null path is returned if
       *   a path was being set and fails a dirty check, unless `fromPath`
       *   was true (in which case no dirty check is performed since this is a
       *   notification of change to a shared path).
       * @protected
       */
      _setPathOrUnmanagedProperty(path, value, fromPath) {
        let rootProperty = Polymer.Path.root(Array.isArray(path) ? path[0] : path);
        let hasEffect = this._hasPropertyEffect(rootProperty);
        let isPath = (rootProperty !== path);
        if (!hasEffect) {
          Polymer.Path.set(this, path, value);
        } else if (isPath && !fromPath) {
          // Dirty check changes being set to a path against the actual object,
          // since this is the entry point for paths into the system; from here
          // the only dirty checks are against the `__dataTemp` cache to prevent
          // duplicate work in the same turn only. Note, if this was a
          // notification of a change already set to a path (fromPath: true),
          // we always let the change through and skip the `set` since it was
          // already dirty checked at the point of entry and the underlying
          // object has already been updated
          let old = Polymer.Path.get(this, path);
          path = Polymer.Path.set(this, path, value);
          // Use property-accessor's simpler dirty check
          if (!super._shouldPropertyChange(path, value, old)) {
            return null;
          }
        } 
        if (hasEffect) {
          return path;
        }
      }

      /**
       * Overrides the `PropertyAccessors` implementation to introduce special
       * dirty check logic depending on the property & value being set:
       *
       * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
       *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
       * 2. Object set to simple property (e.g. 'prop': {...})
       *    Stored in `__dataTemp` and `__data`, dirty checked against
       *    `__dataTemp` by default implementation of `_shouldPropertyChange`
       * 3. Primitive value set to simple property (e.g. 'prop': 42)
       *    Stored in `__data`, dirty checked against `__data`
       *
       * The dirty-check is important to prevent cycles due to two-way
       * notification, but paths and objects are only dirty checked against any
       * previous value set during this turn via a "temporary cache" that is
       * cleared when the last `_propertiesChaged` exits. This is so:
       * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
       *    due to array mutations like shift/unshift/splice; this is fine
       *    since path changes are dirty-checked at user entry points like `set`
       * b. dirty-checking for objects only lasts one turn to allow the user
       *    to mutate the object in-place and re-set it with the same identity
       *    and have all sub-properties re-propagated in a subsequent turn.
       *
       * The temp cache is not necessarily sufficient to prevent invalid array
       * paths, since a splice can happen during the same turn (with pathological
       * user code); we could introduce a "fixup" for temporarily cached array
       * paths if needed: https://github.com/Polymer/polymer/issues/4227
       *
       * @override
       */
      _setPendingProperty(property, value) {
        let isPath = Polymer.Path.isPath(property);
        let prevProps = isPath ? this.__dataTemp : this.__data;
        if (this._shouldPropertyChange(property, value, prevProps[property])) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          // Ensure old is captured from the last turn
          if (!(property in this.__dataOld)) {
            this.__dataOld[property] = this.__data[property];
          }
          // Paths and objects are stored in temporary cache (cleared at end of
          // turn), which is used for dirty-checking
          if (isPath || typeof value == 'object') {
            this.__dataTemp[property] = value;
          }
          // Properties (but not sub-paths) get stored __data cache, used to
          // return accessor values from getters
          if (!isPath) {
            this.__data[property] = value;
          }
          // All changes go into pending property bag, passed to _propertiesChanged
          this.__dataPending[property] = value;
          return true;
        }
      }

      /**
       * Overrides default PropertyAccessors implementation to pull the value
       * to dirty check against from the `__dataTemp` cache (rather than the 
       * normal `__data` cache) for Objects.  Since the temp cache is cleared
       * at the end of a turn, this implementation allows side-effects of deep
       * object changes to be processed by re-setting the same object (using
       * the temp cache as a backstop to prevent cycles due to 2-way
       * notification).
       *
       * Override this to provide more strict dirty checking, i.e. immutable
       * (`value === old`) or based on type.
       *
       * @override
       */
      _shouldPropertyChange(property, value, old) {
        if (typeof value == 'object') {
          old = this.__dataTemp[property];
        }
        return super._shouldPropertyChange(property, value, old);
      }

      /**
       * Overrides PropertyAccessor's default async queuing of 
       * `_propertiesChanged`: if `__dataInitialized` is false (has not yet been
       * manually flushed), the function no-ops; otherwise flushes
       * `_propertiesChanged` synchronously.
       *
       * Subclasses may set `this._asyncEffects = true` to cause 
       * `_propertiesChanged` to be flushed asynchronously.
       *
       * @override
       */
      _invalidateProperties() {
        if (this.__dataInitialized) {
          if (this._asyncEffects) {
            super._invalidateProperties();
          } else {
            this._flushProperties();
          }
        }
      }

      /**
       * Enqueues the given client on a list of pending clients, whose
       * pending property changes can later be flushed via a call to
       * `_flushClients`.
       *
       * @param {Object} client PropertyEffects client to enqueue
       * @protected
       */
      _enqueueClient(client) {
        this.__dataPendingClients = this.__dataPendingClients || new Map();
        if (client !== this) {
          this.__dataPendingClients.set(client, true);
        }
      }

      /**
       * Flushes any clients previously enqueued via `_enqueueClient`, causing
       * their `_flushProperties` method to run.
       *
       * @protected
       */
      _flushClients() {
        // Flush all clients
        let clients = this.__dataPendingClients;
        if (clients) {
          this.__dataPendingClients = null;
          clients.forEach((v, client) => {
            // TODO(kschaaf): more explicit check?
            if (client._flushProperties) {
              client._flushProperties(true);
            }
          });
        }
      }

      /**
       * Sets a bag of property (or path) changes to this instance, and
       * synchronously processes all effects of the properties as a batch.
       *
       * @param {Object} props Bag of one or more key-value pairs whose key is
       *   a property (or path, such as `'object.foo'`) and value is the new
       *   value to set for that property.
       */
      setProperties(props) {
        for (let path in props) {
          if (!this._hasReadOnlyEffect(path)) {
            let value = props[path];
            if ((path = this._setPathOrUnmanagedProperty(path, value))) {
              this._setPendingProperty(path, value);
            }
          }
        }
        this._invalidateProperties();
      }
      /**
       * Overrides PropertyAccessor's default async queuing of 
       * `_propertiesChanged`, to instead synchronously flush
       * `_propertiesChanged` unless the `this._asyncEffects` property is true.
       *
       * If this is the first time properties are being flushed, the `ready`
       * callback will be called.
       *
       * Also adds an optional `fromAbove` argument to indicate when properties
       * are being flushed by a host during data propagation. This information
       * is used to avoid sending upwards notification events in response to
       * downward data flow.  This is a performance optimization, but also
       * critical to avoid infinite looping when an object is notified, since
       * the default implementation of `_shouldPropertyChange` always returns
       * true for Objects, and without would result in a notify-propagate-notify
       * loop.
       *
       * @param {boolean=} fromAbove When true, sets `this.__dataFromAbove` to
       *   `true` for the duration of the call to `_propertiesChanged`.
       * @override
       */
      _flushProperties(fromAbove) {
        if (!this.__dataInitialized) {
          this.ready();
        }
        if (this.__dataPending || this.__dataPendingClients) {
          this.__dataFromAbove = fromAbove;
          super._flushProperties();
          if (!this.__dataCounter) {
            // Clear temporary cache at end of turn
            this.__dataTemp = {};
          }
          this.__dataFromAbove = false;
        }
      }

      /**
       * Polymer-specific lifecycle callback called the first time properties
       * are being flushed.  Prior to `ready`, all property sets through
       * accessors are queued and their effects are flushed after this method
       * returns.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its properties initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or binding values propagated from host
       * "binding effects".  `super.ready()` must be called to ensure the
       * data system becomes enabled.
       *
       * @public
       */
      ready() {
        this.__dataInitialized = true;
      }

      /**
       * Stamps the provided template and performs instance-time setup for
       * Polymer template features, including data bindings, declarative event
       * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
       * is returned containing the stamped DOM, ready for insertion into the
       * DOM.
       * 
       * Note that for host data to be bound into the stamped DOM, the template
       * must have been previously bound to the prototype via a call to
       * `_bindTemplate`, which performs one-time template binding work.
       *
       * Note that this method currently only supports being called once per
       * instance.
       *
       * @param {HTMLTemplateElement} template Template to stamp
       * @return {DocumentFragment} Cloned template content
       * @protected
       */
      _stampTemplate(template) {
        let dom = super._stampTemplate(template);
        let notes = (template._content || template.content)._notes;
        setupBindings(this, dom, notes);
        return dom;
      }

      /**
       * Implements `PropertyAccessors`'s properties changed callback.
       *
       * Runs each class of effects for the batch of changed properties in
       * a specific order (compute, propagate, reflect, observe, notify).
       *
       * @override
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {
        // ----------------------------
        // let c = Object.getOwnPropertyNames(changedProps || {});
        // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
        // if (window.debug) { debugger; }
        // ----------------------------
        let fromAbove = this.__dataFromAbove;
        // Compute properties
        let computedProps = runComputedEffects(this, changedProps, oldProps);
        // Compute linked paths
        computedProps = computeLinkedPaths(this, changedProps, computedProps);
        // Propagate properties to clients
        runEffects(this, TYPES.PROPAGATE, changedProps);
        // Flush clients
        this._flushClients();
        // Reflect properties
        runEffects(this, TYPES.REFLECT, changedProps, oldProps);
        // Observe properties
        runEffects(this, TYPES.OBSERVE, changedProps, oldProps);
        // Notify properties to host
        runNotifyEffects(this, fromAbove ? computedProps : changedProps, oldProps);
        // ----------------------------
        // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
        // ----------------------------
      }

      /**
       * Aliases one data path as another, such that path notifications from one
       * are routed to the other.
       *
       * @method linkPaths
       * @param {string} to Target path to link.
       * @param {string} from Source path to link.
       * @public
       */
      linkPaths(to, from) {
        to = Polymer.Path.normalize(to);
        from = Polymer.Path.normalize(from);
        this.__dataLinkedPaths = this.__dataLinkedPaths || {};
        if (from) {
          this.__dataLinkedPaths[to] = from;
        } else {
          this.__dataLinkedPaths(to);
        }
      }

      /**
       * Removes a data path alias previously established with `_linkPaths`.
       *
       * Note, the path to unlink should be the target (`to`) used when
       * linking the paths.
       *
       * @method unlinkPaths
       * @param {string} path Target path to unlink.
       * @public
       */
      unlinkPaths(path) {
        path = Polymer.Path.normalize(path);
        if (this.__dataLinkedPaths) {
          delete this.__dataLinkedPaths[path];
        }
      }

      /**
       * Notify that an array has changed.
       *
       * Example:
       *
       *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
       *     ...
       *     this.items.splice(1, 1, {name: 'Sam'});
       *     this.items.push({name: 'Bob'});
       *     this.notifySplices('items', [
       *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
       *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
       *     ]);
       *
       * @param {string} path Path that should be notified.
       * @param {Array} splices Array of splice records indicating ordered
       *   changes that occurred to the array. Each record should have the
       *   following fields:
       *    * index: index at which the change occurred
       *    * removed: array of items that were removed from this index
       *    * addedCount: number of new items added at this index
       *    * object: a reference to the array in question
       *    * type: the string literal 'splice'
       *
       *   Note that splice records _must_ be normalized such that they are
       *   reported in index order (raw results from `Object.observe` are not
       *   ordered and must be normalized/merged before notifying).
       * @public
      */
      notifySplices(path, splices) {
        let info = {};
        let array = Polymer.Path.get(this, path, info);
        notifySplices(this, array, info.path, splices);
      }

      /**
       * Convenience method for reading a value from a path.
       *
       * Note, if any part in the path is undefined, this method returns
       * `undefined` (this method does not throw when dereferencing undefined
       * paths).
       *
       * @method get
       * @param {(string|Array<(string|number)>)} path Path to the value
       *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `users.12.name` or `['users', 12, 'name']`).
       * @param {Object=} root Root object from which the path is evaluated.
       * @return {*} Value at the path, or `undefined` if any part of the path
       *   is undefined.
       * @public
       */
      get(path, root) {
        return Polymer.Path.get(root || this, path);
      }

      /**
       * Convenience method for setting a value to a path and notifying any
       * elements bound to the same path.
       *
       * Note, if any part in the path except for the last is undefined,
       * this method does nothing (this method does not throw when
       * dereferencing undefined paths).
       *
       * @method set
       * @param {(string|Array<(string|number)>)} path Path to the value
       *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
       *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
       *   bracketed expressions are not supported; string-based path parts
       *   *must* be separated by dots.  Note that when dereferencing array
       *   indices, the index may be used as a dotted part directly
       *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
       * @param {*} value Value to set at the specified path.
       * @param {Object=} root Root object from which the path is evaluated.
       *   When specified, no notification will occur.
       * @public
      */
      set(path, value, root) {
        if (root) {
          Polymer.Path.set(root, path, value);
        } else {
          if (!this._hasReadOnlyEffect(path)) {
            if ((path = this._setPathOrUnmanagedProperty(path, value))) {
              this._setProperty(path, value);
            }
          }          
        }
      }

      /**
       * Adds items onto the end of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method push
       * @param {String} path Path to array.
       * @param {...any} var_args Items to push onto array
       * @return {number} New length of the array.
       * @public
       */
      push(path, ...items) {
        let info = {};
        let array = Polymer.Path.get(this, path, info);
        let len = array.length;
        let ret = array.push(...items);
        if (items.length) {
          notifySplice(this, array, info.path, len, items.length, []);
        }
        return ret;
      }

      /**
       * Removes an item from the end of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method pop
       * @param {String} path Path to array.
       * @return {any} Item that was removed.
       * @public
       */
      pop(path) {
        let info = {};
        let array = Polymer.Path.get(this, path, info);
        let hadLength = Boolean(array.length);
        let ret = array.pop();
        if (hadLength) {
          notifySplice(this, array, info.path, array.length, 0, [ret]);
        }
        return ret;
      }

      /**
       * Starting from the start index specified, removes 0 or more items
       * from the array and inserts 0 or more new items in their place.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.splice`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method splice
       * @param {String} path Path to array.
       * @param {number} start Index from which to start removing/inserting.
       * @param {number} deleteCount Number of items to remove.
       * @param {...any} var_args Items to insert into array.
       * @return {Array} Array of removed items.
       * @public
       */
      splice(path, start, deleteCount, ...items) {
        let info = {};
        let array = Polymer.Path.get(this, path, info);
        // Normalize fancy native splice handling of crazy start values
        if (start < 0) {
          start = array.length - Math.floor(-start);
        } else {
          start = Math.floor(start);
        }
        if (!start) {
          start = 0;
        }
        let ret = array.splice(start, deleteCount, ...items);
        if (items.length || ret.length) {
          notifySplice(this, array, info.path, start, items.length, ret);
        }
        return ret;
      }

      /**
       * Removes an item from the beginning of array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.pop`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method shift
       * @param {String} path Path to array.
       * @return {any} Item that was removed.
       * @public
       */
      shift(path) {
        let info = {};
        let array = Polymer.Path.get(this, path, info);
        let hadLength = Boolean(array.length);
        let ret = array.shift();
        if (hadLength) {
          notifySplice(this, array, info.path, 0, 0, [ret]);
        }
        return ret;
      }

      /**
       * Adds items onto the beginning of the array at the path specified.
       *
       * The arguments after `path` and return value match that of
       * `Array.prototype.push`.
       *
       * This method notifies other paths to the same array that a
       * splice occurred to the array.
       *
       * @method unshift
       * @param {String} path Path to array.
       * @param {...any} var_args Items to insert info array
       * @return {number} New length of the array.
       * @public
       */
      unshift(path, ...items) {
        let info = {};
        let array = Polymer.Path.get(this, path, info);
        let ret = array.unshift(...items);
        if (items.length) {
          notifySplice(this, array, info.path, 0, items.length, []);
        }
        return ret;
      }

      /**
       * Notify that a path has changed.
       *
       * Example:
       *
       *     this.item.user.name = 'Bob';
       *     this.notifyPath('item.user.name');
       *
       * @param {string} path Path that should be notified.
       * @param {*=} value Value at the path (optional).
       * @public
      */
      notifyPath(path, value) {
        if (arguments.length == 1) {
          // Get value if not supplied
          let info = {};
          value = Polymer.Path.get(this, path, info);
          path = info.path;
        } else if (Array.isArray(path)) {
          // Normalize path if needed
          path = Polymer.Path.normalize(path);
        }
        this._setProperty(path, value);
      }

      /**
       * Creates a read-only accessor for the given property.
       *
       * To set the property, use the protected `_setProperty` API.
       * To create a custom protected setter (e.g. `_setMyProp()` for 
       * property `myProp`), pass `true` for `protectedSetter`.
       *
       * Note, if the property will have other property effects, this method
       * should be called first, before adding other effects.
       *
       * @param {string} property Property name
       * @param {boolean=} protectedSetter Creates a custom protected setter
       *   when `true`.
       * @protected
       */
      _createReadOnlyProperty(property, protectedSetter) {
        this._addPropertyEffect(property, TYPES.READ_ONLY);
        if (protectedSetter) {
          this['_set' + upper(property)] = function(value) {
            this._setProperty(property, value);
          }
        }
      }

      /**
       * Creates a single-property observer for the given property.
       *
       * @param {string} property Property name
       * @param {string} methodName Name of observer method to call
       * @protected
       */
      _createObservedProperty(property, methodName) {
        this._addPropertyEffect(property, TYPES.OBSERVE, {
          fn: runObserverEffect,
          info: {
            methodName: methodName
          }
        });
      }

      /**
       * Creates a multi-property "method observer" based on the provided
       * expression, which should be a string in the form of a normal Javascript
       * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
       * should correspond to a property or path in the context of this
       * prototype (or instance), or may be a literal string or number.
       *
       * @param {string} expression Method expression
       * @protected
       */
      _createMethodObserver(expression) {
        let sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed observer expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.OBSERVE, runMethodObserverEffect);
      }

      /**
       * Causes the setter for the given property to dispatch `<property>-changed`
       * events to notify of changes to the property.
       *
       * @param {string} property Property name
       * @protected
       */
      _createNotifyingProperty(property) {
        this._addPropertyEffect(property, TYPES.NOTIFY, {
          fn: runNotifyEffect,
          info: {
            eventName: CaseMap.camelToDashCase(property) + '-changed',
            property: property
          }
        });
      }

      /**
       * Causes the setter for the given property to reflect the property value
       * to a (dash-cased) attribute of the same name.
       *
       * @param {string} property Property name
       * @protected
       */
      _createReflectedProperty(property) {
        let attr = CaseMap.camelToDashCase(property);
        if (attr[0] === '-') {
          console.warn('Property ' + property + ' cannot be reflected to attribute ' +
            attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
        } else {
          this._addPropertyEffect(property, TYPES.REFLECT, {
            fn: runReflectEffect,
            info: {
              attrName: attr
            }
          });
        }
      }

      /**
       * Creates a computed property whose value is set to the result of the
       * method described by the given `expression` each time one or more
       * arguments to the method changes.  The expression should be a string
       * in the form of a normal Javascript function signature:
       * `'methodName(arg1, [..., argn])'`
       *
       * @param {string} property Name of computed property to set
       * @param {string} expression Method expression
       * @protected
       */
      _createComputedProperty(property, expression) {
        let sig = parseMethod(expression);
        if (!sig) {
          throw new Error("Malformed computed expression '" + expression + "'");
        }
        createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property);
      }

      // -- binding ----------------------------------------------

      /**
       * Creates "binding" property effects for all binding bindings
       * in the provided template that forward host properties into DOM stamped
       * from the template via `_stampTemplate`.
       *
       * @param {HTMLTemplateElement} template Template containing binding
       *   bindings
       * @protected
       */
      _bindTemplate(template) {
        // Clear any existing propagation effects inherited from superClass
        this[TYPES.PROPAGATE] = {};
        let notes = this._parseTemplateAnnotations(template);
        processAnnotations(notes);
        for (let i=0, note; (i<notes.length) && (note=notes[i]); i++)  {
          // where to find the node in the concretized list
          let b$ = note.bindings;
          for (let j=0, binding; (j<b$.length) && (binding=b$[j]); j++) {
            if (shouldAddListener(binding)) {
              addAnnotatedListener(this, i, binding.name,
                binding.parts[0].value,
                binding.parts[0].event,
                binding.parts[0].negate);
            }
            addBindingEffect(this, binding, i);
          }
        }
      }

    }

  });

})();
</script><!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
(function() {
  'use strict';

  var StyleGather = {
    MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',
    INCLUDE_ATTR: 'include',
    _importModule(moduleId) {
      if (!Polymer.DomModule) {
        return null;
      }
      return Polymer.DomModule.import(moduleId);
    },
    cssFromModules(moduleIds, warnIfNotFound) {
      var modules = moduleIds.trim().split(' ');
      var cssText = '';
      for (var i=0; i < modules.length; i++) {
        cssText += this.cssFromModule(modules[i], warnIfNotFound);
      }
      return cssText;
    },

    // returns cssText of styles in a given module; also un-applies any
    // styles that apply to the document.
    cssFromModule(moduleId, warnIfNotFound) {
      var m = this._importModule(moduleId);
      if (m && !m._cssText) {
        m._cssText = this.cssFromElement(m);
      }
      if (!m && warnIfNotFound) {
        console.warn('Could not find style data in module named', moduleId);
      }
      return m && m._cssText || '';
    },

    // support lots of ways to discover css...
    cssFromElement(element) {
      var cssText = '';
      // if element is a template, get content from its .content
      var content = element.content || element;
      var e$ = content.querySelectorAll(this.MODULE_STYLES_SELECTOR);
      for (var i=0, e; i < e$.length; i++) {
        e = e$[i];
        // look inside templates for elements
        if (e.localName === 'template') {
          cssText += this.cssFromElement(e);
        } else {
          // style elements inside dom-modules will apply to the main document
          // we don't want this, so we remove them here.
          if (e.localName === 'style') {
            var include = e.getAttribute(this.INCLUDE_ATTR);
            // now support module refs on 'styling' elements
            if (include) {
              cssText += this.cssFromModules(include, true);
            }
            // get style element applied to main doc via HTMLImports polyfill
            e = e.__appliedElement || e;
            e.parentNode.removeChild(e);
            cssText += Polymer.ResolveUrl.resolveCss(e.textContent, element.ownerDocument);
            // it's an import, assume this is a text file of css content.
            // TODO(sorvell): plan is to deprecate this way to get styles;
            // remember to add deprecation warning when this is done.
          } else if (e.import && e.import.body) {
            cssText += Polymer.ResolveUrl.resolveCss(e.import.body.textContent, e.import);
          }
        }
      }
      return cssText;
    }
  };

  Polymer.StyleGather = StyleGather;
})();
</script><!--
@license
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
--><script>
  (function() {
    'use strict';

    var StyleUtil = {

      isTargetedBuild: function(buildType) {
        return (!window.ShadyDOM || !ShadyDOM.inUse) ?
          buildType === 'shadow' : buildType === 'shady';
      },

      cssBuildTypeForModule: function (module) {
        var dm = Polymer.DomModule.import(module);
        if (dm) {
          return this.getCssBuildType(dm);
        }
      },

      getCssBuildType: function(element) {
        return element.getAttribute('css-build');
      }

    };

    Polymer.StyleUtil = StyleUtil;

  })();
</script>
<script>
(function() {

  'use strict';

  let caseMap = Polymer.CaseMap;

  // Same as Polymer.Utils.mixin, but upgrades shorthand type
  // syntax to { type: Type }
  function flattenProperties(flattenedProps, props) {
    for (let p in props) {
      let o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  Polymer.ElementMixin = Polymer.Utils.cachingMixin(function(base) {

    return class PolymerElement extends Polymer.PropertyEffects(base) {

      // returns the config object on specifically on `this` class (not super)
      // config is used for:
      // (1) super chain mixes togther to make `flattenedProperties` which is
      // then used to make observedAttributes and set property defaults
      // (2) properties effects and observers are created from it at `finalize` time.
      static get _ownConfig() {
        if (!this.hasOwnProperty('__ownConfig')) {
          this.__ownConfig = this.hasOwnProperty('config') ? this.config : {};
        }
        return this.__ownConfig;
      }

      // a flattened list of properties mixed together from the chain of all
      // constructor's `config.properties`
      // This list is used to create
      // (1) observedAttributes,
      // (2) element default values
      static get _flattenedProperties() {
        if (!this.hasOwnProperty('__flattenedProperties')) {
          // TODO(sorvell): consider optimizing; shorthand type support requires
          // an extra loop to upgrade shorthand property info to longhand
          this.__flattenedProperties = flattenProperties({}, this._ownConfig.properties);
          let superCtor = Object.getPrototypeOf(this.prototype).constructor;
          if (superCtor.prototype instanceof PolymerElement) {
            this.__flattenedProperties = flattenProperties(
              Object.create(superCtor._flattenedProperties),
              this.__flattenedProperties);
          }
        }
        return this.__flattenedProperties;
      }

      static get observedAttributes() {
        if (!this.hasOwnProperty('_observedAttributes')) {
          // observedAttributes must be finalized at registration time
          this._observedAttributes = this._addPropertiesToAttributes(
            this._flattenedProperties, []);
        }
        return this._observedAttributes;
      }

      static _addPropertiesToAttributes(properties, list) {
        for (let prop in properties) {
          list.push(Polymer.CaseMap.camelToDashCase(prop));
        }
        return list;
      }

      static get finalized() {
        return this.hasOwnProperty('_finalized');
      }

      static set finalized(value) {
        this._finalized = value;
      }

      // TODO(sorvell): need to work on public api surrouding `finalize`.
      // Due to meta-programming, it's awkward to make a subclass impl of this.
      // However, a user might want to call `finalize` prior to define to do
      // this work eagerly. Need to also decide on `finalizeConfig(config)` and
      // `finalizeTemplate(template)`. Both are public but have simiarly
      // awkward subclassing characteristics.
      static finalize() {
        let proto = this.prototype;
        if (!this.finalized) {

          let superProto = Object.getPrototypeOf(proto);
          let superCtor = superProto && superProto.constructor;
          if (superCtor.prototype instanceof PolymerElement) {
            superCtor.finalize();
          }
          this.finalized = true;
          if (this.hasOwnProperty('is') && this.is) {
            Polymer.telemetry.register(proto);
          }
          let config = this._ownConfig;
          if (config) {
            this._finalizeConfig(config);
          }
          if (this.template) {
            let template = this.template.cloneNode(true);
            this._finalizeTemplate(template);
          }
        }
      }

      static _finalizeConfig(config) {
        if (config.properties) {
          // process properties
          for (let p in config.properties) {
            this.prototype._createPropertyFromConfig(p, config.properties[p]);
          }
        }
        if (config.observers) {
          for (let i=0; i < config.observers.length; i++) {
            this.prototype._createMethodObserver(config.observers[i]);
          }
        }
      }

      static get template() {
        if (!this.hasOwnProperty('_template')) {
          // TODO(sorvell): support more ways to acquire template.
          // this requires `is` on constructor...
          this._template = Polymer.DomModule.import(this.is, 'template') ||
            // note: implemented so a subclass can retrieve the super
            // template; call the super impl this way so that `this` points
            // to the superclass.
            Object.getPrototypeOf(this.prototype).constructor.template;
        }
        return this._template;
      }

      static _finalizeTemplate(template) {
        // support `include="module-name"`
        let cssText = Polymer.StyleGather.cssFromElement(template);
        if (cssText) {
          let style = document.createElement('style');
          style.textContent = cssText;
          template.content.insertBefore(style, template.content.firstChild);
        }
        if (window.ShadyCSS) {
          window.ShadyCSS.prepareTemplate(template, this.is, this.extends);
        }
        var proto = this.prototype;
        this.prototype._bindTemplate(template);
        proto._template = template;
      }

      constructor() {
        super();
        // note: `this.constructor.prototype` is wrong in Safari so make sure to
        // use `__proto__`
        Polymer.telemetry.instanceCount++;
        // add self to host's pending client list
        hostStack.registerHost(this);
      }

      _initializeProperties() {
        if (!this.constructor.finalized) {
          this.constructor.finalize();
        }
        super._initializeProperties();
        // apply property defaults...
        let p$ = this.constructor._flattenedProperties;
        for (let p in p$) {
          let info = p$[p];
          if (('value' in info) && !this._isPropertyPending(p)) {
            var value = typeof info.value == 'function' ?
              info.value.call(this) :
              info.value;
            if (this._hasReadOnlyEffect(p)) {
              this._setProperty(p, value)
            } else {
              this[p] = value;
            }
          }
        }
      }

      /**
       * Creates effects for a property.
       *
       * Example:
       *
       *     this._createPropertyFromConfig('foo', {
       *       type: String, value: 'foo', reflectToAttribute: true
       *     });
       *
       * Note, once a property has been set to
       * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
       * these values may not be changed. For example, a subclass cannot
       * alter these settings. However, additional `observers` may be added
       * by subclasses.
       *
       * @param {string} name Name of the property.
       * @param {*=} info Info object from which to create property effects.
       * Supported keys:
       *
       * * type: {function} type to which an attribute matching the property
       * is deserialized. Note the property is camel-cased from a dash-cased
       * attribute. For example, 'foo-bar' attribute is dersialized to a
       * property named 'fooBar'.
       *
       * * readOnly: {boolean} creates a readOnly property and
       * makes a private setter for the private of the form '_setFoo' for a
       * property 'foo',
       *
       * * computed: {string} creates a computed property. A computed property
       * also automatically is set to `readOnly: true`. The value is calculated
       * by running a method and arguments parsed from the given string. For
       * example 'compute(foo)' will compute a given property when the
       * 'foo' property changes by executing the 'compute' method. This method
       * must return the computed value.
       *
       * * reflectToAttriute: {boolean} If true, the property value is reflected
       * to an attribute of the same name. Note, the attribute is dash-cased
       * so a property named 'fooBar' is reflected as 'foo-bar'.
       *
       * * notify: {boolean} sends a non-bubbling notification event when
       * the property changes. For example, a property named 'foo' sends an
       * event named 'foo-changed' with `event.detail` set to the value of
       * the property.
       *
       * * observer: {string} name of a method that runs when the property
       * changes. The arguments of the method are (value, previousValue).
       *
      */
      /* TODO(sorvell): Users may want control over modifying property
       effects via subclassing. For example, a user might want to make a
       reflectToAttribute property not do so in a subclass. We've chosen to
       disable this because it leads to additional complication.
       For example, a readOnly effect generates a special setter. If a subclass
       disables the effect, the setter would fail unexpectedly.
       Based on feedback, we may want to try to make effects more malleable
       and/or provide an advanced api for manipulating them.
       Also consider adding warnings when an effect cannot be changed.
      */
      _createPropertyFromConfig(name, info) {
        // computed forces readOnly...
        if (info.computed) {
          info.readOnly = true;
        }
        // Note, since all computed properties are readOnly, this prevents
        // adding additional computed property effects (which leads to a confusing
        // setup where multiple triggers for setting a property)
        // While we do have `hasComputedEffect` this is set on the property's
        // dependencies rather than itself.
        if (info.computed  && !this._hasReadOnlyEffect(name)) {
          this._createComputedProperty(name, info.computed);
        }
        if (info.readOnly && !this._hasReadOnlyEffect(name)) {
          this._createReadOnlyProperty(name, !info.computed);
        }
        if (info.reflectToAttribute && !this._hasReflectEffect(name)) {
          this._createReflectedProperty(name);
        }
        if (info.notify && !this._hasNotifyEffect(name)) {
          this._createNotifyingProperty(name);
        }
        // always add observer
        if (info.observer) {
          this._createObservedProperty(name, info.observer);
        }
      }

      // reserved for canonical behavior
      connectedCallback() {
        if (hostStack.isEmpty()) {
          this._flushProperties();
          this.updateStyles();
        }
      }

      disconnectedCallback() {}

      ready() {
        super.ready();
        if (this._template) {
          hostStack.beginHosting(this);
          this.root = this._stampTemplate(this._template);
          this._flushProperties();
          this.root = this._attachDom(this.root);
          hostStack.endHosting(this);
        } else {
          this.root = this;
          this._flushProperties();
        }
      }

      /**
       * Attach an element's stamped dom to itself. By default,
       * this method creates a `shadowRoot` and adds the dom to it.
       * However, this method may be overridden to allow an element
       * to put its dom in another location.
       *
       * @method _attachDom
       * @param {NodeList} dom to attach to the element.
       * @returns {Node} node to which the dom has been attached.
       */
      _attachDom(dom) {
        if (this.attachShadow) {
          if (dom) {
            if (!this.shadowRoot) {
              this.attachShadow({mode: 'open'});
            }
            this.shadowRoot.appendChild(dom);
            return this.shadowRoot;
          }
        } else {
          throw new Error(`ShadowDOM not available. ` +
            // BREAKME(sorvell): move to developer conditional when supported.
           `Polymer.Element can
              create dom as children instead of in ShadowDOM by setting
              \`this.root = this;\` before \`ready\`.`);
        }
      }

      attributeChangedCallback(name, old, value) {
        if (old !== value) {
          let property = caseMap.dashToCamelCase(name);
          let type = this.constructor._flattenedProperties[property].type;
          if (!this._hasReadOnlyEffect(property)) {
            this._attributeToProperty(name, value, type);
          }
        }
      }

      updateStyles(properties) {
        if (window.ShadyCSS) {
          ShadyCSS.applyStyle(this, properties);
        }
      }

      /**
       * Rewrites a given URL relative to the original location of the document
       * containing the `dom-module` for this element.  This method will return
       * the same URL before and after vulcanization.
       *
       * @method resolveUrl
       * @param {string} url URL to resolve.
       * @return {string} Rewritten URL relative to the import
       */
      resolveUrl(url) {
        var module = Polymer.DomModule.import(this.constructor.is);
        var root = '';
        if (module) {
          var assetPath = module.getAttribute('assetpath') || '';
          root = Polymer.ResolveUrl.resolveUrl(
            assetPath, module.ownerDocument.baseURI);
        }
        return Polymer.ResolveUrl.resolveUrl(url, root);
      }

    }

  });

  let hostStack = {

    stack: [],

    isEmpty() {
      return !this.stack.length;
    },

    registerHost(inst) {
      if (this.stack.length) {
        let host = this.stack[this.stack.length-1];
        host._enqueueClient(inst);
      }
    },

    beginHosting(inst) {
      this.stack.push(inst);
    },

    endHosting(inst) {
      let stackLen = this.stack.length;
      if (stackLen && this.stack[stackLen-1] == inst) {
        this.stack.pop();
      }
    }

  }

  // telemetry
  Polymer.telemetry = {
    instanceCount: 0,
    registrations: [],
    _regLog: function(prototype) {
      console.log('[' + prototype.is + ']: registered')
    },
    register: function(prototype) {
      this.registrations.push(prototype);
      Polymer.log && this._regLog(prototype);
    },
    dumpRegistrations: function() {
      this.registrations.forEach(this._regLog);
    }
  };

  Polymer.Element = Polymer.ElementMixin(HTMLElement);

  Polymer.updateStyles = function(props) {
    if (window.ShadyCSS) {
      ShadyCSS.updateStyles(props);
    }
  };

})();

</script><dom-module id="normalize-styles" assetpath="/">
<template>
<style>
/* normalize.css v3.0.0 | MIT License | git.io/normalize */

/**
 * Tweaked for theguardian.com: there are some elements we don't use
 * as well as properties/elements we restyle later anyway.
 */

/**
 * Prevent iOS text size adjust after orientation change, without disabling
 * user zoom.
 */

html {
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
}

/**
 * Remove default margin.
 */

body {
    margin: 0;
}

/* HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined for any HTML5 element in IE 8/9.
 * Correct `block` display not defined for `details` or `summary` in IE 10/11 and Firefox.
 * Correct `block` display not defined for `main` in IE 11.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * 1. Correct `inline-block` display not defined in IE 8/9.
 * 2. Normalize vertical alignment of `progress` in Chrome, Firefox, and Opera.
 */

audio,
canvas,
progress,
video {
    display: inline-block; /* 1 */
    vertical-align: baseline; /* 2 */
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address `[hidden]` styling not present in IE 8/9/10.
 * Hide the `template` element in IE 8/9/11, Safari, and Firefox < 22.
 */

[hidden],
template {
    display: none;
}

/* Links
   ========================================================================== */

/**
 * Remove the gray background color from active links in IE 10.
 */

a {
    background: transparent;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* Text-level semantics
   ========================================================================== */

/**
 * Address styling not present in IE 8/9/10/11, Safari, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 4+, Safari, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

/**
 * Address styling not present in Safari and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -.5em;
}

sub {
    bottom: -.25em;
}

/* Embedded content
   ========================================================================== */

/**
 * Remove border when inside `a` element in IE 8/9/10.
 */

img {
    border: 0;
}

/**
 * Correct overflow not hidden in IE 9/10/11.
 */

svg:not(:root) {
    overflow: hidden;
}

/* Grouping content
   ========================================================================== */

/**
 * Address margin not present in IE 8/9 and Safari.
 */

figure {
    margin: 1em 0;
}

/**
 * Address differences between Firefox and other browsers.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Contain overflow in all browsers.
 */

pre {
    overflow: auto;
}

/**
 * Address odd `em`-unit font size rendering in all browsers.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, monospace;
    font-size: 1em;
}

/* Forms
   ========================================================================== */

/**
 * Known limitation: by default, Chrome and Safari on OS X allow very limited
 * styling of `select`, unless a `border` property is set.
 */

/**
 * 1. Correct color not being inherited.
 *    Known issue: affects color of disabled elements.
 * 2. Correct font properties not being inherited.
 * 3. Address margins set differently in Firefox 4+, Safari, and Chrome.
 * 4. -webkit-font-smoothing:... does not filter down to buttons
 *    see: http://jameskoster.co.uk/work/using-webkit-font-smoothing-antialiased-check-your-buttons/
 */

button,
input,
optgroup,
select,
textarea {
    color: inherit; /* 1 */
    font: inherit; /* 2 */
    margin: 0; /* 3 */
    -webkit-font-smoothing: antialiased; /* 4 */
}

/**
 * Address `overflow` set to `hidden` in IE 8/9/10/11.
 */

button {
    overflow: visible;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Firefox, IE 8/9/10/11, and Opera.
 * Correct `select` style inheritance in Firefox.
 */

button,
select {
    text-transform: none;
}

/**
 * As pasteup-buttons are adding :focus and :active pseudo classes to the button
 * class as default we can safely set outline to 0 and keep the accessibility.
 */
.button {
    outline: 0;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 */

button,
html input[type='button'], /* 1 */
input[type='reset'],
input[type='submit'] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * Remove inner padding and border in Firefox 4+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * Address Firefox 4+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

input {
    line-height: normal;
}

/**
 * It's recommended that you don't attempt to style these elements.
 * Firefox's implementation doesn't respect box-sizing, padding, or width.
 *
 * 1. Address box sizing set to `content-box` in IE 8/9/10.
 * 2. Remove excess padding in IE 8/9/10.
 */

input[type='checkbox'],
input[type='radio'] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
}

/**
 * Fix the cursor style for Chrome's increment/decrement buttons. For certain
 * `font-size` values of the `input`, it causes the cursor style of the
 * decrement button to change from `default` to `text`.
 */

input[type='number']::-webkit-inner-spin-button,
input[type='number']::-webkit-outer-spin-button {
    height: auto;
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari and Chrome
 *    (include `-moz` to future-proof).
 */

input[type='search'] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari and Chrome on OS X.
 * Safari (but not Chrome) clips the cancel button when the search input has
 * padding (and `textfield` appearance).
 */

input[type='search']::-webkit-search-cancel-button,
input[type='search']::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * 1. Correct `color` not being inherited in IE 8/9/10/11.
 * 2. Remove padding so people aren't caught out if they zero out fieldsets.
 */

legend {
    border: 0; /* 1 */
    padding: 0; /* 2 */
}

/**
 * Remove default vertical scrollbar in IE 8/9/10/11.
 */

textarea {
    overflow: auto;
}

/**
 * Don't inherit the `font-weight` (applied by a rule above).
 * NOTE: the default cannot safely be changed in Chrome and Safari on OS X.
 */

optgroup {
    font-weight: bold;
}

/* Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

td,
th {
    padding: 0;
}

</style>
</template>
</dom-module><dom-module id="base-styles" assetpath="/">
<template>
<style>
/* Base styles */
body {
 /* font-family: "Guardian Egyptian Text", Georgia, serif; */
  line-height: 24px;
  padding: 0 10px;
  width: 78.75rem;
}

ul {
    margin: 0;
    padding: 0;
}

li {
  padding: 0;
  list-style: none;
}

h2 {
  font-weight: 500;
  margin: 0;
}

a {
  color: #005689;
  text-decoration: none;
}
</style>
</template>
</dom-module><dom-module id="facia-card-content" assetpath="app/">
  <template>
    <style include="normalize-styles"></style>
    <style include="base-styles">
      .fc-item__header {
          color: #ffffff;
          font-size: 1.25rem;
          line-height: 1.5rem;
          font-family: "Guardian Egyptian Headline", Georgia, serif;
          font-weight: normal;
          font-weight: 500;
          padding-bottom: .5em
      }

      .fc-item__headline {
          color: var(--tone, black);
      }

      .fc-item__standfirst {
          font-size: 0.875rem;
          line-height: 1.125rem;
          font-family: "Guardian Egyptian Text", Georgia,serif;
          font-weight: normal;
          padding-bottom: .5em;
          color: #767676;
      }

      .fc-item__kicker:after {
          color: rgb(214, 214, 214);
          content: "/";
          display: inline-block;
          height: 20px;
          margin-left: 3.2px;
          width: 5.65625px;
      }

      .tone-news--item .fc-item__kicker {
          color: #005689;
      }

      .fc-item__content {
        padding-left: 0.3125rem;
        padding-right: 0.3125rem
      }

      .fc-item__kicker,
      .fc-item__title {
          font-size: inherit;
      }

      /* Visited Styles Omitted */

      /* Hidden overlayed anchor */

      a.u-faux-block-link__overlay {
          position: absolute;
          z-index: 0;
          opacity: 0;
      }

      .u-faux-block-link__overlay {
          top: 0;
          right: 0;
          bottom: 0;
          left: 0;
          overflow: hidden;
          text-indent: 200%;
          white-space: nowrap;
          background: transparent;
      }
    </style>
    <!-- local DOM goes here -->
    <div class="fc-item__content">
        <div class="fc-item__header">
            <h2 class="fc-item__title"><a href="https://www.theguardian.com/technology/2016/dec/14/yahoo-hack-security-of-one-billion-accounts-breached" class="fc-item__link" data-link-name="article"><span class="fc-item__kicker">Yahoo hack</span> <span class="u-faux-block-link__cta fc-item__headline"> <span class="js-headline-text">1bn accounts compromised by biggest data breach in history</span></span> </a></h2>
        </div>
        <div class="fc-item__standfirst">
            The latest incident to emerge – which happened in 2013 – is probably distinct from the breach of 500m user accounts in 2014
        </div>
        <a href="https://www.theguardian.com/technology/2016/dec/14/yahoo-hack-security-of-one-billion-accounts-breached" class="u-faux-block-link__overlay js-headline-text" data-link-name="article" tabindex="-1">1bn accounts compromised by biggest data breach in history</a>
    </div>
  </template>
  <script>
    // Extend Polymer.Element base class
    class FaciaCardContent extends Polymer.Element {
      static get is() { return 'facia-card-content'; }
    }

    // Register custom element definition using standard platform API
    customElements.define(FaciaCardContent.is, FaciaCardContent);
  </script>
</dom-module>
<dom-module id="facia-card-image" assetpath="app/">
  <template>
    <style include="normalize-styles"></style>
    <style include="base-styles">
      /* local styles go here */
      :host {
        display: inline-block;
      }
    </style>
    <!-- local DOM goes here -->
    <div class="fc-item__media-wrapper">
        <div class="fc-item__image-container u-responsive-ratio inlined-image">
            <picture>
                <!--[if IE 9]><video style="display: none;"><![endif]-->
                <source media="(min-width: 980px) and (-webkit-min-device-pixel-ratio: 1.25), (min-width: 980px) and (min-resolution: 120dpi)" sizes="220px" srcset="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=220&amp;q=20&amp;auto=format&amp;usm=12&amp;fit=max&amp;dpr=2&amp;s=f46cee161012621401f0f6d962506122 440w">
                <source media="(min-width: 980px)" sizes="220px" srcset="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=220&amp;q=55&amp;auto=format&amp;usm=12&amp;fit=max&amp;s=67983b697aff49d2c98245074af9ee17 220w">
                <source media="(min-width: 740px) and (-webkit-min-device-pixel-ratio: 1.25), (min-width: 740px) and (min-resolution: 120dpi)" sizes="160px" srcset="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=160&amp;q=20&amp;auto=format&amp;usm=12&amp;fit=max&amp;dpr=2&amp;s=23e38038db72b1c407bb13e4c7041ad5 320w">
                <source media="(min-width: 740px)" sizes="160px" srcset="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=160&amp;q=55&amp;auto=format&amp;usm=12&amp;fit=max&amp;s=a2dd33b97c1791b753b23de303a615ab 160w">
                <source media="(min-width: 0px) and (-webkit-min-device-pixel-ratio: 1.25), (min-width: 0px) and (min-resolution: 120dpi)" sizes="127px" srcset="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=127&amp;q=20&amp;auto=format&amp;usm=12&amp;fit=max&amp;dpr=2&amp;s=d8e5d716d327f3dbbd79d0824bedde9d 254w">
                <source media="(min-width: 0px)" sizes="127px" srcset="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=127&amp;q=55&amp;auto=format&amp;usm=12&amp;fit=max&amp;s=a0a096e824eed62c287ae9ffa3af710e 127w">
                <!--[if IE 9]></video><![endif]-->
                <img class="responsive-img" alt="" src="https://i.guim.co.uk/img/media/849294625d777a2810944a85a8af7d07752d3df9/0_102_4096_2458/master/4096.jpg?w=300&amp;q=55&amp;auto=format&amp;usm=12&amp;fit=max&amp;s=af1aad5e9179e2401935d8c626e2c461">
            </picture>
        </div>
    </div>
  </template>
  <script>
    // Extend Polymer.Element base class
    class FaciaCardImage extends Polymer.Element {
      static get is() { return 'facia-card-image'; }
    }

    // Register custom element definition using standard platform API
    customElements.define(FaciaCardImage.is, FaciaCardImage);
  </script>
</dom-module>
<dom-module id="facia-card" assetpath="app/">
  <template>
    <style include="normalize-styles"></style>
    <style include="base-styles">
      .fc-item {
        width: 220px; /* just fix the width for now */
      }

      /* Facia card */

      .fc-item {
          background-color: #f6f6f6; /* $story-package tone */
      }

      .fc-item a {
          color: #333;
      }

      .fc-item__container {
          position: relative;
      }

      /* The blue line above the facia card */
      .tone-news--item .rich-link__container:before,
      .tone-news--item .fc-item__container:before {
          background-color: var(--tone, #4bc6df);
      }

      .fc-item__container:before,
      .item__container:before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          height: 0.0625rem;
          z-index: 2;
      }

      /* When hovering the u-faux-block-link, the `.u-faux-block-link--hover` class should be added to .fc-item__container */
      .fc-item .u-faux-block-link--hover {
          color: inherit;
          background-color: #eaeaea; /* mix($story-package, $neutral-1, 50%) */
      }
    </style>
    <!-- local DOM goes here -->
    <li class="u-faux-block-link">
      <div class="fc-item fc-item--force-image-upgrade fc-item--has-image fc-item--has-metadata fc-item--has-sublinks-1 fc-item--is-commentable js-fc-item tone-news--item fc-item--list-media-mobile fc-item--standard-tablet js-snappable" data-discussion-closed="false" data-discussion-url="https://www.theguardian.com/technology/2016/dec/14/yahoo-hack-security-of-one-billion-accounts-breached#comments" data-link-name="news | group-1 | card-4" data-item-visibility="all" data-test-id="facia-card" data-id="technology/2016/dec/14/yahoo-hack-security-of-one-billion-accounts-breached" data-loyalty-short-url="/p/5g4jt" data-node-uid="15">
            <div class="fc-item__container">
              <facia-card-image></facia-card-image>
              <facia-card-content></facia-card-content>
            </div>
      </div>
    </li>
  </template>
  <script>
    // Extend Polymer.Element base class
    class FaciaCard extends Polymer.Element {
      static get is() { return 'facia-card'; }
    }

    // Register custom element definition using standard platform API
    customElements.define(FaciaCard.is, FaciaCard);
  </script>
</dom-module>
</div>
    <h1>Polymer</h1>
      <h2 style="color: red; font-size: 100px;">Rejected</h2>
      <dom-module id="facia-card-container">
          <template>
            <style>
                facia-card[tone=opinion] {
                  --tone: #e6711b;
                }
            </style>

            <ul class="prototype__fixed-width">
              <facia-card></facia-card>
              <facia-card tone="opinion"></facia-card>
            </ul>

          </template>

          <script>
            // Extend Polymer.Element base class
            class FaciaCardContainer extends Polymer.Element {
              static get is() { return 'facia-card-container'; }
            }

            // Register custom element definition using standard platform API
            customElements.define(FaciaCardContainer.is, FaciaCardContainer);
          </script>
      </dom-module>

      <facia-card-container></facia-card-container>
  

</body></html>